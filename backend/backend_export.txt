MERN BACKEND EXPORT
Date: 2025-03-16T00:14:23.573Z
Project Structure: C:\Users\Admin\OneDrive\forkina-FullStackProject\forkina-FullStackProject\backend
================================================================================


================================================================================
FILE: models\classModel.js
================================================================================

// models/classModel.js
const mongoose = require('mongoose');
const { Schema } = mongoose;

const classSchema = new Schema(
  {
    name: { type: String, required: true, unique: true },
    description: { type: String },
    tutor: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true // The tutor assigned to this class
    },
    students: [{
      type: Schema.Types.ObjectId,
      ref: 'User'
    }],
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true // The admin who created the class
    }
  },
  { timestamps: true }
);

module.exports = mongoose.model('Class', classSchema);
================================================================================
FILE: models\evaluationModel.js
================================================================================

// models/evaluationModel.js
const mongoose = require('mongoose');
const { Schema } = mongoose;

const evaluationSchema = new Schema(
  {
    date:    { type: Date, default: Date.now },
    comment: { type: String },
    note:    { type: Number, default: 0 },
    userRef: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true
    }
  },
  { timestamps: true }
);

module.exports = mongoose.model('Evaluation', evaluationSchema);

================================================================================
FILE: models\fileModel.js
================================================================================

const mongoose = require('mongoose');
const { Schema } = mongoose;

const fileSchema = new Schema(
  {
    filename: { 
      type: String, 
      required: true 
    },
    originalName: { 
      type: String, 
      required: true 
    },
    path: { 
      type: String, 
      required: true 
    },
    mimetype: { 
      type: String, 
      required: true 
    },
    size: { 
      type: Number, 
      required: true 
    },
    description: { 
      type: String,
      default: ''
    },
    uploadedBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    projectRef: {
      type: Schema.Types.ObjectId,
      ref: 'Project',
      required: true
    },
    taskRef: {
      type: Schema.Types.ObjectId,
      ref: 'Task',
      default: null
    },
    isPublic: {
      type: Boolean,
      default: false
    },
    tags: [String]
  },
  { timestamps: true }
);

module.exports = mongoose.model('File', fileSchema); 
================================================================================
FILE: models\milestoneModel.js
================================================================================

// models/milestoneModel.js
const mongoose = require('mongoose');
const { Schema } = mongoose;

const milestoneSchema = new Schema(
  {
    name:    { type: String, required: true },
    dueDate: { type: Date },
    isDone:  { type: Boolean, default: false },
    // belongs to a project
    projectRef: {
      type: Schema.Types.ObjectId,
      ref: 'Project',
      required: true
    }
  },
  { timestamps: true }
);

module.exports = mongoose.model('Milestone', milestoneSchema);

================================================================================
FILE: models\notificationModel.js
================================================================================

// models/notificationModel.js
const mongoose = require('mongoose');

const notificationSchema = new mongoose.Schema({
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    message: { type: String, required: true },
    read: { type: Boolean, default: false },
    createdAt: { type: Date, default: Date.now },
});

module.exports = mongoose.model('Notification', notificationSchema);
================================================================================
FILE: models\PasswordResetToken.js
================================================================================

const mongoose = require('mongoose');

const passwordResetTokenSchema = new mongoose.Schema({
  token: {
    type: String,
    required: true,
  },
  email: { // Ajout du champ email
    type: String,
    required: true,
  },
  expiresAt: { // Ajout du champ expiresAt pour la date d'expiration
    type: Date,
    required: true,
  }
});

const PasswordResetToken = mongoose.model('PasswordResetToken', passwordResetTokenSchema);
module.exports = PasswordResetToken;

================================================================================
FILE: models\projectModel.js
================================================================================

const mongoose = require('mongoose');
const { Schema } = mongoose;

const ProjectStatus = {
    PENDING: 'PENDING',
    IN_PROGRESS: 'IN_PROGRESS',
    COMPLETED: 'COMPLETED',
    ARCHIVED: 'ARCHIVED'
};

const projectSchema = new Schema(
    {
        name: { type: String, required: true },
        description: { type: String, required: true },
        creationDate: { type: Date, default: Date.now },
        startDate: { type: Date },
        endDate: { type: Date },
        status: {
            type: String,
            enum: Object.values(ProjectStatus),
            default: ProjectStatus.PENDING
        },
        tutorRef: {
            type: Schema.Types.ObjectId,
            ref: 'User',
            required: false
        },
        teamRef: {
            type: Schema.Types.ObjectId,
            ref: 'Team',
            default: null
        },
        members: [{
            user: {
                type: Schema.Types.ObjectId,
                ref: 'User',
            },
            role: {
                type: String,
                enum: ['TUTOR', 'STUDENT'],
                default: 'STUDENT'
            },
            dateJoined: {
                type: Date,
                default: Date.now
            }
        }],
        tags: [String],
        progressPercentage: {
            type: Number,
            default: 0,
            min: 0,
            max: 100
        },
        classes: [{ type: Schema.Types.ObjectId, ref: 'Class' }], // Add the classes field
    },
    { timestamps: true }
);

// Calculate progress based on completed tasks
projectSchema.methods.updateProgress = async function() {
    const Task = mongoose.model('Task');
    const totalTasks = await Task.countDocuments({ projectRef: this._id });

    if (totalTasks === 0) {
        this.progressPercentage = 0;
        return;
    }

    const completedTasks = await Task.countDocuments({
        projectRef: this._id,
        status: 'COMPLETED'
    });

    this.progressPercentage = Math.round((completedTasks / totalTasks) * 100);
    await this.save();
};

module.exports = mongoose.model('Project', projectSchema);
================================================================================
FILE: models\studentResumeModel.js
================================================================================

// models/studentResumeModel.js
const mongoose = require('mongoose');
const { Schema } = mongoose;

const LevelEnum = {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED'
};

const studentResumeSchema = new Schema(
  {
    skills:   [{ type: String }], // array of strings
    diplomas: [{ type: String }], // array of strings
    grade:    { type: String },
    level: {
      type: String,
      enum: Object.values(LevelEnum),
      default: LevelEnum.BEGINNER
    },
    // link to the user who owns this student resume
    userRef: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      unique: true // each user can have 1 student resume
    }
  },
  { timestamps: true }
);

module.exports = mongoose.model('StudentResume', studentResumeSchema);

================================================================================
FILE: models\taskModel.js
================================================================================

const mongoose = require('mongoose');
const { Schema } = mongoose;

const TaskStatus = {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

const TaskPriority = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

const taskSchema = new Schema(
  {
    title: { type: String, required: true },
    description: { type: String },
    status: {
      type: String,
      enum: Object.values(TaskStatus),
      default: TaskStatus.TODO
    },
    priority: {
      type: String,
      enum: Object.values(TaskPriority),
      default: TaskPriority.MEDIUM
    },
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    assignedTo: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      default: null
    },
    dueDate: { type: Date },
    startDate: { type: Date },
    completedDate: { type: Date },
    estimatedHours: { type: Number },
    actualHours: { type: Number },
    projectRef: {
      type: Schema.Types.ObjectId,
      ref: 'Project',
      required: true
    },
    milestoneRef: {
      type: Schema.Types.ObjectId,
      ref: 'Milestone',
      default: null
    },
    tags: [{ type: String }],
    comments: [{
      author: { type: Schema.Types.ObjectId, ref: 'User', required: true },
      content: { type: String, required: true },
      createdAt: { type: Date, default: Date.now },
      updatedAt: { type: Date, default: Date.now }
    }]
  },
  { timestamps: true }
);

taskSchema.post('save', async function() {
  if (this.projectRef) {
    const Project = mongoose.model('Project');
    const project = await Project.findById(this.projectRef);
    if (project) await project.updateProgress();
  }
});

module.exports = mongoose.model('Task', taskSchema)
================================================================================
FILE: models\teamModel.js
================================================================================

// models/teamModel.js
const mongoose = require('mongoose');
const { Schema } = mongoose;

const teamSchema = new Schema(
  {
    name: { type: String, required: true },
    creationDate: { type: Date, default: Date.now },
    score: { type: Number, default: 0 },
    projectRef: {
      type: Schema.Types.ObjectId,
      ref: 'Project',
      default: null
    },
    classRef: {  // Add reference to the class
      type: Schema.Types.ObjectId,
      ref: 'Class',
      required: true
    },
    members: [{  // Add members array
      user: {
        type: Schema.Types.ObjectId,
        ref: 'User',
        required: true
      },
      dateJoined: {
        type: Date,
        default: Date.now
      }
    }],
    createdBy: {  // Add creator reference
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true
    }
  },
  { timestamps: true }
);

module.exports = mongoose.model('Team', teamSchema);
================================================================================
FILE: models\tutorResumeModel.js
================================================================================

// models/tutorResumeModel.js
const mongoose = require('mongoose');
const { Schema } = mongoose;

const LevelEnum = {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED'
};

const tutorResumeSchema = new Schema(
  {
    specialization: [{ type: String }], // array of strings
    experience:     [{ type: String }], // array of strings
    linkedInLink:   { type: String },
    level: {
      type: String,
      enum: Object.values(LevelEnum),
      default: LevelEnum.BEGINNER
    },
    score: { type: Number, default: 0 },
    // link to the user who owns this tutor resume
    userRef: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      unique: true // each user can have 1 tutor resume
    }
  },
  { timestamps: true }
);

module.exports = mongoose.model('TutorResume', tutorResumeSchema);

================================================================================
FILE: models\User.js
================================================================================

const mongoose = require("mongoose");
const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
  },
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  avatar: {
    type: String,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model("User", userSchema); 
================================================================================
FILE: models\userModel.js
================================================================================

// models/userModel.js
const mongoose = require('mongoose');
const bcrypt = require("bcryptjs");
const jwt = require('jsonwebtoken');
const { Schema } = mongoose;

const UserRole = {
  STUDENT: 'STUDENT',
  TUTOR: 'TUTOR',
  ADMIN: 'ADMIN'
};

const userSchema = new Schema(
  {
    firstName: { type: String, required: true },
    // Reference to Class model instead of a string
    classe: { 
      type: Schema.Types.ObjectId,
      ref: 'Class',
      default: null // Default to null if not assigned to a class
    },
    lastName: { type: String, required: true },
    email: { 
      type: String, 
      required: true, 
      unique: true,
      lowercase: true,
      trim: true
    },
    password: { 
      type: String, 
      required: function() {
        return !this.isGoogleUser && !this.isGithubUser; // Password not required for OAuth users
      }
    },
    // CIN - Carte d'Identité Nationale
    cin: { 
      type: String,
      trim: true,
      sparse: true,
      // Required only for students
      required: function() {
        return this.userRole === UserRole.STUDENT;
      }
    },
    // Classe de l'étudiant
    classe: { 
      type: String,
      default: "--" // Par défaut, pas encore affecté
    },
    educationLevel: {
      type: String,
      enum: ['BEGINNER', 'INTERMEDIATE', 'ADVANCED'],
      default: 'BEGINNER'
    },
    isGoogleUser: { type: Boolean, default: false },
    isGithubUser: { type: Boolean, default: false },
    accountStatus: { type: Boolean, default: true },
    phone: { type: String },
    userRole: {
      type: String,
      enum: Object.values(UserRole),
      default: UserRole.STUDENT
    },
    teamRef: {
      type: Schema.Types.ObjectId,
      ref: 'Team',
      default: null
    },
    profilePicture: { type: String },
    faceImage: { type: String }, // Stored path to the face image
    faceDescriptor: { type: [Number] }, // Face descriptor as an array of numbers
    lastLogin: { type: Date },
    loginCount: { type: Number, default: 0 },
    googleId: {
      type: String,
      unique: true,
      sparse: true,
    },
    githubId: {
      type: String,
      unique: true,
      sparse: true,
    },
    avatar: {
      type: String,
    },
  },
  { 
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
  }
);

// Pre-save middleware to hash password if modified
userSchema.pre("save", async function (next) {
  if (!this.isModified("password") || !this.password) return next();
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (err) {
    next(err);
  }
});

// Instance method to compare passwords during login
userSchema.methods.comparePassword = async function (candidatePassword) {
  if (!this.password) return false;
  return bcrypt.compare(candidatePassword, this.password);
};

// Generate JWT token
userSchema.methods.generateToken = function() {
  return jwt.sign(
    { 
      id: this._id,
      email: this.email,
      role: this.userRole,
      isGoogleUser: this.isGoogleUser
    },
    process.env.JWT_SECRET || 'your-jwt-secret',
    { expiresIn: '7d' }
  );
};

// Remove sensitive data from responses
userSchema.methods.toJSON = function () {
  const obj = this.toObject();
  delete obj.password;
  delete obj.faceDescriptor; // Don't expose face descriptor in API responses
  return obj;
};

module.exports = mongoose.model("User", userSchema);
================================================================================
FILE: models\VerifyEmailToken.js
================================================================================

const mongoose = require('mongoose');

const verifyEmailTokenSchema = new mongoose.Schema({
  token: {
    type: String,
    required: true,
  },
  email: { // Ajout du champ email
    type: String,
    required: true,
  },
  expiresAt: { // Ajout du champ expiresAt pour la date d'expiration
    type: Date,
    required: true,
  }
});

const VerifyEmailToken = mongoose.model('VerifyEmailToken', verifyEmailTokenSchema);
module.exports = VerifyEmailToken;

================================================================================
FILE: controllers\authController.js
================================================================================

const bcrypt = require("bcryptjs");
const User = require("../models/userModel");
const generateToken = require("../utils/generateToken");
const crypto = require('crypto');
const nodemailer = require('nodemailer');
const fetch = require('node-fetch');
const BASE_URL = process.env.NODE_ENV === 'production' ? 'https://mon-app.com' : 'http://localhost:5173';
const { OAuth2Client } = require('google-auth-library');
const jwt = require('jsonwebtoken');

const PasswordResetToken = require('../models/PasswordResetToken');
const Verifyemail = require('../models/VerifyEmailToken');

const invalidatedTokens = new Set();

// Stockage en mémoire des tentatives de connexion échouées et des blocages temporaires
const failedLoginAttempts = {}; // { email: { count: number, lastAttempt: timestamp } }
const tempBlockedAccounts = {}; // { email: timestamp } timestamp = moment de déblocage

// Register function
const register = async (req, res) => {
  const { firstName, lastName, email, password, role, adminSecret, faceImage, faceDescriptor, cin } = req.body;
  try {
    const existingUser = await User.findOne({ email });
    if (existingUser) return res.status(400).json({ message: "User already exists" });
    
    // Validation du CIN pour les étudiants
    if (role === "STUDENT" && !cin) {
      return res.status(400).json({ message: "CIN is required for student accounts" });
    }
    
    // Vérifier si le CIN existe déjà pour un autre étudiant
    if (cin) {
      const userWithCin = await User.findOne({ cin });
      if (userWithCin) return res.status(400).json({ message: "CIN already exists in the system" });
    }
    
    // Create user with face data if provided
    const user = new User({ 
      firstName, 
      lastName, 
      email, 
      password, 
      userRole: role || "STUDENT", 
      isVerified: false,
      faceImage: faceImage || null, // Add face image if provided
      faceDescriptor: faceDescriptor || null, // Add face descriptor if provided
      cin: cin || null, // Add CIN if provided
      classe: "--" // Par défaut, pas encore affecté
    });
    
    await user.save();
    const generatedToken = crypto.randomBytes(32).toString('hex');
    const newToken = new Verifyemail({ token: generatedToken, email, expiresAt: Date.now() + 3600000 });
    await newToken.save();
    const transporter = nodemailer.createTransport({ service: 'hotmail', auth: { user: 'Firdaous.JEBRI@esprit.tn', pass: 'xwbcgpyxnwghflrk' }, tls: { rejectUnauthorized: false }});
    await transporter.sendMail({ from: 'Firdaous.JEBRI@esprit.tn', to: email, subject: 'Email Verification', html: `<h1>Email Verification</h1><p>Please verify your email by clicking the link below:</p><a href="${BASE_URL}/verify-email/${generatedToken}">Verify Email</a>`});
    res.status(201).json({ message: "User registered successfully. Verification email sent.", user });
  } catch (error) { res.status(500).json({ message: "Server error", error: error.message }); }
};

// Email verification function
const verifyEmail = async (req, res) => {
  try {
    const { token } = req.params;
    const emailToken = await Verifyemail.findOne({ token });
    if (!emailToken || emailToken.expiresAt < Date.now()) return res.status(400).json({ message: "Invalid or expired token" });
    const user = await User.findOne({ email: emailToken.email });
    if (!user) return res.status(400).json({ message: "User not found" });
    user.isVerified = true;
    await user.save();
    await Verifyemail.deleteOne({ token });
    res.status(200).json({ message: "Email verified successfully" });
  } catch (error) { res.status(500).json({ message: "Server error", error: error.message }); }
};

// Placeholder functions to fix missing exports
const login = async (req, res) => {
  const { email, password } = req.body;
  
  try {
    // Validation des champs
    if (!email || !password) {
      return res.status(400).json({ message: "Email and password are required" });
    }
    
    // Vérifier si le compte est temporairement bloqué
    if (tempBlockedAccounts[email] && tempBlockedAccounts[email] > Date.now()) {
      // Calculer le temps restant en minutes et secondes
      const remainingTime = Math.ceil((tempBlockedAccounts[email] - Date.now()) / 1000);
      const minutes = Math.floor(remainingTime / 60);
      const seconds = remainingTime % 60;
      
      return res.status(429).json({ 
        message: `Votre compte est temporairement bloqué suite à plusieurs tentatives de connexion infructueuses. Réessayez dans ${minutes} minute${minutes !== 1 ? 's' : ''} et ${seconds} seconde${seconds !== 1 ? 's' : ''} ou réinitialisez votre mot de passe.`,
        blockedUntil: tempBlockedAccounts[email]
      });
    }
    
    // Recherche de l'utilisateur par email
    const user = await User.findOne({ email });
    if (!user) {
      // Incrémenter les tentatives échouées
      updateFailedAttempts(email);
      
      return res.status(401).json({ 
        message: "Invalid email or password",
        remainingAttempts: getRemainingAttempts(email)
      });
    }
    
    // Vérification du mot de passe
    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      // Incrémenter les tentatives échouées
      updateFailedAttempts(email);
      
      // Vérifier si le compte doit être bloqué
      if (shouldBlockAccount(email)) {
        blockAccount(email);
        return res.status(429).json({ 
          message: "Votre compte est temporairement bloqué suite à plusieurs tentatives de connexion infructueuses. Réessayez dans 2 minutes ou réinitialisez votre mot de passe.",
          blockedUntil: tempBlockedAccounts[email]
        });
      }
      
      return res.status(401).json({ 
        message: "Invalid email or password", 
        remainingAttempts: getRemainingAttempts(email)
      });
    }
    
    // Réinitialiser les tentatives échouées après un login réussi
    resetFailedAttempts(email);
    
    // Mise à jour des statistiques de connexion
    user.lastLogin = new Date();
    user.loginCount += 1;
    await user.save();
    
    // Génération du token JWT
    const token = user.generateToken();
    
    // Réponse avec données utilisateur et token
    res.status(200).json({
      message: "Login successful",
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        role: user.userRole
      },
      token
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Fonctions utilitaires pour la gestion des tentatives
function updateFailedAttempts(email) {
  if (!failedLoginAttempts[email]) {
    failedLoginAttempts[email] = { count: 1, lastAttempt: Date.now() };
  } else {
    failedLoginAttempts[email].count += 1;
    failedLoginAttempts[email].lastAttempt = Date.now();
  }
}

function getRemainingAttempts(email) {
  if (!failedLoginAttempts[email]) return 3;
  return Math.max(0, 3 - failedLoginAttempts[email].count);
}

function shouldBlockAccount(email) {
  return failedLoginAttempts[email] && failedLoginAttempts[email].count >= 3;
}

function blockAccount(email) {
  const blockDuration = 2 * 60 * 1000; // 2 minutes en millisecondes
  tempBlockedAccounts[email] = Date.now() + blockDuration;
}

function resetFailedAttempts(email) {
  delete failedLoginAttempts[email];
  delete tempBlockedAccounts[email];
}

const googleLogin = async (req, res) => {
  try {
    const { token } = req.body;
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID
    });
    const { email, name, picture } = ticket.getPayload();
    
    let user = await User.findOne({ email });
    if (!user) {
      user = await User.create({
        email,
        name,
        avatar: picture,
        provider: 'google'
      });
    }

    const jwtToken = jwt.sign({ id: user._id }, process.env.JWT_SECRET);
    res.cookie('token', jwtToken, { httpOnly: true });
    res.status(200).json({ user });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

const logout = async (req, res) => res.status(200).json({ message: "Logout function is missing" });
const forgotPassword = async (req, res) => res.status(200).json({ message: "Forgot password function is missing" });
const resetPassword = async (req, res) => res.status(200).json({ message: "Reset password function is missing" });
const checkTokenValidity = async (req, res, next) => next();

// Export all functions
module.exports = {
  register,
  verifyEmail,
  login,
  googleLogin,
  logout,
  forgotPassword,
  resetPassword,
  checkTokenValidity
};
================================================================================
FILE: controllers\classController.js
================================================================================

// controllers/classController.js
const Class = require('../models/classModel');
const User = require('../models/userModel');

// Create a new class (Admin only)
exports.createClass = async (req, res) => {
  try {
    // Only admins can create classes
    if (req.user.role !== 'ADMIN') {
      return res.status(403).json({ message: 'Only admins can create classes' });
    }

    const { name, description, tutorId } = req.body;

    // Validate tutor
    const tutor = await User.findById(tutorId);
    if (!tutor || tutor.userRole !== 'TUTOR') {
      return res.status(400).json({ message: 'Invalid tutor ID or user is not a tutor' });
    }

    // Check if class name already exists
    const existingClass = await Class.findOne({ name });
    if (existingClass) {
      return res.status(400).json({ message: 'Class name already exists' });
    }

    // Create the class
    const newClass = new Class({
      name,
      description,
      tutor: tutorId,
      createdBy: req.user.id,
      students: []
    });

    await newClass.save();

    // Assign the class to the tutor
    tutor.classe = newClass._id;
    await tutor.save();

    // Populate tutor details for response
    await newClass.populate('tutor', 'firstName lastName email');
    await newClass.populate('createdBy', 'firstName lastName email');

    return res.status(201).json(newClass);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

// Add students to a class (Admin only)
exports.addStudentsToClass = async (req, res) => {
    try {
      if (req.user.role !== 'ADMIN') {
        return res.status(403).json({ message: 'Only admins can add students to classes' });
      }
  
      const { classId, studentIds } = req.body;
  
      // Validate class
      const classDoc = await Class.findById(classId);
      if (!classDoc) {
        return res.status(404).json({ message: 'Class not found' });
      }
  
      // Validate students
      const students = await User.find({ _id: { $in: studentIds }, userRole: 'STUDENT' });
      if (students.length !== studentIds.length) {
        return res.status(400).json({ message: 'One or more student IDs are invalid or users are not students' });
      }
  
      // Check if any student is already in another class
      for (const student of students) {
        if (student.classe && student.classe.toString() !== classId) {
          return res.status(400).json({ message: `Student ${student.email} is already assigned to another class` });
        }
      }
  
      // Add students to the class (avoid duplicates)
      classDoc.students = [...new Set([...classDoc.students, ...studentIds])];
      await classDoc.save();
  
      // Update each student's classe field
      await User.updateMany(
        { _id: { $in: studentIds } },
        { classe: classId }
      );
  
      // Get the updated class with correct counts
      const updatedClassDoc = await Class.findById(classId)
        .populate('students', 'firstName lastName email')
        .populate('tutor', 'firstName lastName email')
        .populate('createdBy', 'firstName lastName email');
  
      return res.json(updatedClassDoc);
    } catch (err) {
      return res.status(400).json({ error: err.message });
    }
  };
  

// Get all classes (Admin or Tutor)
exports.getAllClasses = async (req, res) => {
  try {
    let query = {};

    // Tutors can only see their assigned classes
    if (req.user.role === 'TUTOR') {
      query.tutor = req.user.id;
    }

    const classes = await Class.find(query)
      .populate('tutor', 'firstName lastName email')
      .populate('students', 'firstName lastName email')
      .populate('createdBy', 'firstName lastName email');

    return res.json(classes);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// Get a specific class by ID (Admin or Tutor)
exports.getClassById = async (req, res) => {
  try {
    const classDoc = await Class.findById(req.params.id)
      .populate('tutor', 'firstName lastName email')
      .populate('students', 'firstName lastName email cin classe educationLevel')
      .populate('createdBy', 'firstName lastName email');

    if (!classDoc) {
      return res.status(404).json({ message: 'Class not found' });
    }

    // Tutors can only access their own classes
    if (req.user.role === 'TUTOR' && classDoc.tutor._id.toString() !== req.user.id) {
      return res.status(403).json({ message: 'You do not have access to this class' });
    }

    return res.json(classDoc);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// Update a class (Admin only)
exports.updateClass = async (req, res) => {
  try {
    if (req.user.role !== 'ADMIN') {
      return res.status(403).json({ message: 'Only admins can update classes' });
    }

    const { name, description, tutorId } = req.body;

    const classDoc = await Class.findById(req.params.id);
    if (!classDoc) {
      return res.status(404).json({ message: 'Class not found' });
    }

    // Update tutor if provided
    if (tutorId) {
      const newTutor = await User.findById(tutorId);
      if (!newTutor || newTutor.userRole !== 'TUTOR') {
        return res.status(400).json({ message: 'Invalid tutor ID or user is not a tutor' });
      }

      // Remove class assignment from the old tutor
      const oldTutor = await User.findById(classDoc.tutor);
      if (oldTutor) {
        oldTutor.classe = null;
        await oldTutor.save();
      }

      // Assign class to the new tutor
      newTutor.classe = classDoc._id;
      await newTutor.save();

      classDoc.tutor = tutorId;
    }

    // Update other fields
    if (name) classDoc.name = name;
    if (description) classDoc.description = description;

    await classDoc.save();

    await classDoc.populate('tutor', 'firstName lastName email');
    await classDoc.populate('students', 'firstName lastName email');
    await classDoc.populate('createdBy', 'firstName lastName email');

    return res.json(classDoc);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

// Delete a class (Admin only)
exports.deleteClass = async (req, res) => {
  try {
    if (req.user.role !== 'ADMIN') {
      return res.status(403).json({ message: 'Only admins can delete classes' });
    }

    const classDoc = await Class.findById(req.params.id);
    if (!classDoc) {
      return res.status(404).json({ message: 'Class not found' });
    }

    // Remove class assignment from tutor
    const tutor = await User.findById(classDoc.tutor);
    if (tutor) {
      tutor.classe = null;
      await tutor.save();
    }

    // Remove class assignment from students
    await User.updateMany(
      { _id: { $in: classDoc.students } },
      { classe: null }
    );

    // Delete the class
    await Class.findByIdAndDelete(req.params.id);

    return res.json({ message: 'Class deleted successfully' });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// Get all students across all classes for a tutor
exports.getAllStudentsForTutor = async (req, res) => {
  try {
    if (req.user.role !== 'TUTOR') {
      return res.status(403).json({ message: 'Only tutors can access this endpoint' });
    }

    // Find all classes assigned to the tutor
    const classes = await Class.find({ tutor: req.user.id });

    // Extract all student IDs from these classes
    const studentIds = classes.reduce((acc, curr) => {
      return [...acc, ...curr.students];
    }, []);

    // Remove duplicates
    const uniqueStudentIds = [...new Set(studentIds.map(id => id.toString()))];

    // Fetch student details, including accountStatus
    const students = await User.find({
      _id: { $in: uniqueStudentIds },
      userRole: 'STUDENT'
    }).select('firstName lastName email cin classe educationLevel accountStatus'); // Add accountStatus

    return res.json(students);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

================================================================================
FILE: controllers\evaluationController.js
================================================================================

// controllers/evaluationController.js
const Evaluation = require('../models/evaluationModel');

exports.createEvaluation = async (req, res) => {
  try {
    const evaluation = new Evaluation(req.body);
    await evaluation.save();
    return res.status(201).json(evaluation);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.getAllEvaluations = async (req, res) => {
  try {
    const evaluations = await Evaluation.find().populate('userRef');
    return res.json(evaluations);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.getEvaluationById = async (req, res) => {
  try {
    const evaluation = await Evaluation.findById(req.params.id).populate('userRef');
    if (!evaluation) {
      return res.status(404).json({ error: 'Evaluation not found' });
    }
    return res.json(evaluation);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.updateEvaluation = async (req, res) => {
  try {
    const evaluation = await Evaluation.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    if (!evaluation) {
      return res.status(404).json({ error: 'Evaluation not found' });
    }
    return res.json(evaluation);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.deleteEvaluation = async (req, res) => {
  try {
    const evaluation = await Evaluation.findByIdAndDelete(req.params.id);
    if (!evaluation) {
      return res.status(404).json({ error: 'Evaluation not found' });
    }
    return res.json({ message: 'Evaluation deleted successfully' });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

================================================================================
FILE: controllers\fileController.js
================================================================================

// controllers/fileController.js
const File = require('../models/fileModel');
const Project = require('../models/projectModel');
const Task = require('../models/taskModel');
const fs = require('fs');
const path = require('path');
const multer = require('multer');

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, '../uploads/projects');
    
    // Create the directory if it doesn't exist
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    // Create a unique filename
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const extension = path.extname(file.originalname);
    cb(null, `${uniqueSuffix}${extension}`);
  }
});

// File filter to restrict file types
const fileFilter = (req, file, cb) => {
  // Allowed file types
  const allowedTypes = [
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-powerpoint',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'text/plain',
    'image/jpeg',
    'image/png',
    'image/gif',
    'application/zip',
    'application/x-7z-compressed',
    'application/x-rar-compressed'
  ];
  
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only documents, images, and archives are allowed.'), false);
  }
};

// Create multer upload instance
exports.upload = multer({ 
  storage,
  fileFilter,
  limits: { 
    fileSize: 10 * 1024 * 1024 // 10MB file size limit
  }
});

// Upload a file
exports.uploadFile = async (req, res) => {
  try {
    // Check if file exists in request
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    const { projectId, taskId, description, isPublic, tags } = req.body;
    
    // Check if project exists
    const project = await Project.findById(projectId);
    if (!project) {
      // Delete the uploaded file
      fs.unlinkSync(req.file.path);
      return res.status(404).json({ error: 'Project not found' });
    }
    
    // Check if user has access to this project
    const isMember = project.members.some(m => m.user.toString() === req.user.id);
    const isTutor = project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';
    
    if (!isMember && !isTutor && !isAdmin) {
      // Delete the uploaded file
      fs.unlinkSync(req.file.path);
      return res.status(403).json({ error: 'You do not have permission to upload files to this project' });
    }
    
    // If taskId is provided, check if it exists and belongs to the project
    let task = null;
    if (taskId) {
      task = await Task.findById(taskId);
      if (!task || task.projectRef.toString() !== projectId) {
        // Delete the uploaded file
        fs.unlinkSync(req.file.path);
        return res.status(404).json({ error: 'Task not found or does not belong to the specified project' });
      }
    }
    
    // Create file record
    const file = new File({
      filename: req.file.filename,
      originalName: req.file.originalname,
      path: req.file.path,
      mimetype: req.file.mimetype,
      size: req.file.size,
      description: description || '',
      uploadedBy: req.user.id,
      projectRef: projectId,
      taskRef: taskId || null,
      isPublic: isPublic === 'true' || isPublic === true,
      tags: tags ? tags.split(',').map(tag => tag.trim()) : []
    });
    
    await file.save();
    
    // If file is attached to a task, update the task's attachments
    if (task) {
      task.attachments.push({
        filename: req.file.filename,
        originalName: req.file.originalname,
        path: req.file.path,
        mimetype: req.file.mimetype,
        size: req.file.size,
        uploadedBy: req.user.id,
        uploadedAt: new Date()
      });
      
      await task.save();
    }
    
    // Populate user info
    await file.populate('uploadedBy', 'firstName lastName email');
    
    return res.status(201).json(file);
  } catch (err) {
    // Delete the uploaded file if there was an error
    if (req.file) {
      fs.unlinkSync(req.file.path);
    }
    
    return res.status(400).json({ error: err.message });
  }
};

// Get all files for a project
exports.getProjectFiles = async (req, res) => {
  try {
    const { projectId } = req.params;
    
    // Check if project exists
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    
    // Check if user has access to this project
    const isMember = project.members.some(m => m.user.toString() === req.user.id);
    const isTutor = project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';
    
    if (!isMember && !isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have access to this project' });
    }
    
    // Get files for the project
    const files = await File.find({ projectRef: projectId })
      .populate('uploadedBy', 'firstName lastName email')
      .sort({ createdAt: -1 });
      
    return res.json(files);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// Get all files for a task
exports.getTaskFiles = async (req, res) => {
  try {
    const { taskId } = req.params;
    
    // Check if task exists
    const task = await Task.findById(taskId);
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    // Check if user has access to this task's project
    const project = await Project.findById(task.projectRef);
    if (!project) {
      return res.status(404).json({ error: 'Associated project not found' });
    }
    
    const isMember = project.members.some(m => m.user.toString() === req.user.id);
    const isTutor = project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';
    
    if (!isMember && !isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have access to this task' });
    }
    
    // Get files for the task
    const files = await File.find({ taskRef: taskId })
      .populate('uploadedBy', 'firstName lastName email')
      .sort({ createdAt: -1 });
      
    return res.json(files);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// Get file by ID
exports.getFileById = async (req, res) => {
  try {
    const file = await File.findById(req.params.id)
      .populate('uploadedBy', 'firstName lastName email');
      
    if (!file) {
      return res.status(404).json({ error: 'File not found' });
    }
    
    // Check if file is public
    if (file.isPublic) {
      return res.json(file);
    }
    
    // Check if user has access to the file's project
    const project = await Project.findById(file.projectRef);
    if (!project) {
      return res.status(404).json({ error: 'Associated project not found' });
    }
    
    const isMember = project.members.some(m => m.user.toString() === req.user.id);
    const isTutor = project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';
    
    if (!isMember && !isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have access to this file' });
    }
    
    return res.json(file);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// Download file
exports.downloadFile = async (req, res) => {
  try {
    const file = await File.findById(req.params.id);
    if (!file) {
      return res.status(404).json({ error: 'File not found' });
    }
    
    // Check if file is public
    if (file.isPublic) {
      // Send the file
      return res.download(file.path, file.originalName);
    }
    
    // Check if user has access to the file's project
    const project = await Project.findById(file.projectRef);
    if (!project) {
      return res.status(404).json({ error: 'Associated project not found' });
    }
    
    const isMember = project.members.some(m => m.user.toString() === req.user.id);
    const isTutor = project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';
    
    if (!isMember && !isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have access to this file' });
    }
    
    // Send the file
    return res.download(file.path, file.originalName);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

// Delete file
exports.deleteFile = async (req, res) => {
  try {
    const file = await File.findById(req.params.id);
    if (!file) {
      return res.status(404).json({ error: 'File not found' });
    }
    
    // Check if user has permission to delete this file
    const isOwner = file.uploadedBy.toString() === req.user.id;
    
    // Check if user is a tutor or admin for the project
    const project = await Project.findById(file.projectRef);
    if (!project) {
      return res.status(404).json({ error: 'Associated project not found' });
    }
    
    const isTutor = project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';
    
    if (!isOwner && !isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have permission to delete this file' });
    }
    
    // Delete from task's attachments if associated with a task
    if (file.taskRef) {
      const task = await Task.findById(file.taskRef);
      if (task) {
        task.attachments = task.attachments.filter(a => a.filename !== file.filename);
        await task.save();
      }
    }
    
    // Delete the physical file
    fs.unlinkSync(file.path);
    
    // Delete the file record
    await File.findByIdAndDelete(req.params.id);
    
    return res.json({ message: 'File deleted successfully' });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
}; 
================================================================================
FILE: controllers\milestoneController.js
================================================================================

// controllers/milestoneController.js
const Milestone = require('../models/milestoneModel');

exports.createMilestone = async (req, res) => {
  try {
    const milestone = new Milestone(req.body);
    await milestone.save();
    return res.status(201).json(milestone);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.getAllMilestones = async (req, res) => {
  try {
    const milestones = await Milestone.find().populate('projectRef');
    return res.json(milestones);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.getMilestoneById = async (req, res) => {
  try {
    const milestone = await Milestone.findById(req.params.id).populate('projectRef');
    if (!milestone) {
      return res.status(404).json({ error: 'Milestone not found' });
    }
    return res.json(milestone);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.updateMilestone = async (req, res) => {
  try {
    const milestone = await Milestone.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    if (!milestone) {
      return res.status(404).json({ error: 'Milestone not found' });
    }
    return res.json(milestone);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.deleteMilestone = async (req, res) => {
  try {
    const milestone = await Milestone.findByIdAndDelete(req.params.id);
    if (!milestone) {
      return res.status(404).json({ error: 'Milestone not found' });
    }
    return res.json({ message: 'Milestone deleted successfully' });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

================================================================================
FILE: controllers\notificationController.js
================================================================================

// controllers/notificationController.js
const Notification = require('../models/notificationModel');

exports.getUserNotifications = async (req, res) => {
  try {
    const notifications = await Notification.find({ user: req.user.id })
        .sort({ createdAt: -1 });
    return res.json(notifications);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.markNotificationAsRead = async (req, res) => {
  try {
    const notification = await Notification.findOneAndUpdate(
        { _id: req.params.id, user: req.user.id },
        { read: true },
        { new: true }
    );
    if (!notification) {
      return res.status(404).json({ message: 'Notification not found' });
    }
    return res.json(notification);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};
================================================================================
FILE: controllers\projectController.js
================================================================================

const Project = require('../models/projectModel');
const User = require('../models/userModel');
const Task = require('../models/taskModel');
const Class = require('../models/classModel');
const {Types} = require("mongoose"); // Add Class model

exports.createProject = async (req, res) => {
  try {
    const { name, description, startDate, endDate, tags, status, classIds } = req.body;

    if (req.user.role !== 'TUTOR' && req.user.role !== 'ADMIN') {
      return res.status(403).json({ message: 'Only tutors and admins can create projects' });
    }

    // Validate classIds if provided
    if (classIds && Array.isArray(classIds)) {
      const classes = await Class.find({ _id: { $in: classIds } });
      if (classes.length !== classIds.length) {
        return res.status(400).json({ message: 'One or more class IDs are invalid' });
      }
    }

    const project = new Project({
      name,
      description,
      startDate,
      endDate,
      tags: tags || [],
      status: status || 'PENDING',
      tutorRef: req.user.role === 'TUTOR' ? req.user.id : null,
      members: req.user.role === 'TUTOR' ? [{ user: req.user.id, role: 'TUTOR' }] : [],
      classes: classIds || [], // Add classes
    });

    console.log('Creating project with data:', { name, description, startDate, endDate, tags, status, tutorRef: project.tutorRef, classes: project.classes });
    await project.save();

    await project.populate('tutorRef', 'firstName lastName email');
    await project.populate('members.user', 'firstName lastName email');
    await project.populate('classes', 'name description');

    return res.status(201).json(project);
  } catch (err) {
    console.error('Error creating project:', err);
    return res.status(400).json({ error: err.message });
  }
};

exports.getAllProjects = async (req, res) => {
  try {
    const { status, tutor, search } = req.query;
    const filter = {};

    if (status) filter.status = status;
    if (tutor) filter.tutorRef = tutor;
    if (search) {
      filter.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { tags: { $regex: search, $options: 'i' } }
      ];
    }

    if (req.user.role === 'STUDENT') {
      filter['members.user'] = req.user.id;
    } else if (req.user.role === 'TUTOR') {
      filter.tutorRef = req.user.id;
    }

    const projects = await Project.find(filter)
        .populate('tutorRef', 'firstName lastName email')
        .populate('members.user', 'firstName lastName email userRole')
        .populate('teamRef')
        .populate('classes', 'name description')
        .sort({ createdAt: -1 });

    return res.json(projects);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.getProjectById = async (req, res) => {
  try {
    const project = await Project.findById(req.params.id)
        .populate('tutorRef', 'firstName lastName email')
        .populate('members.user', 'firstName lastName email userRole')
        .populate('teamRef')
        .populate('classes', 'name description');

    if (!project) return res.status(404).json({ error: 'Project not found' });

    const isMember = project.members.some(m => m.user._id.toString() === req.user.id);
    const isTutor = project.tutorRef && project.tutorRef._id.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isMember && !isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have access to this project' });
    }

    const tasks = await Task.find({ projectRef: project._id })
        .populate('assignedTo', 'firstName lastName email')
        .populate('createdBy', 'firstName lastName email');

    return res.json({ project, tasks });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.updateProject = async (req, res) => {
  try {
    const { name, description, status, startDate, endDate, tags } = req.body;

    const project = await Project.findById(req.params.id);
    if (!project) return res.status(404).json({ error: 'Project not found' });

    const isTutor = project.tutorRef && project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have permission to update this project' });
    }

    if (name) project.name = name;
    if (description) project.description = description;
    if (status) project.status = status;
    if (startDate) project.startDate = startDate;
    if (endDate) project.endDate = endDate;
    if (tags) project.tags = tags;

    await project.save();
    await project.populate('tutorRef', 'firstName lastName email');
    await project.populate('members.user', 'firstName lastName email');

    return res.json(project);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.deleteProject = async (req, res) => {
  try {
    const project = await Project.findById(req.params.id);
    if (!project) return res.status(404).json({ error: 'Project not found' });

    const isTutor = project.tutorRef && project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have permission to delete this project' });
    }

    await Task.deleteMany({ projectRef: project._id });
    await Project.findByIdAndDelete(req.params.id);

    return res.json({ message: 'Project and associated tasks deleted successfully' });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.addProjectMember = async (req, res) => {
  try {
    const { userId, role } = req.body;
    const project = await Project.findById(req.params.id);
    if (!project) return res.status(404).json({ error: 'Project not found' });

    const isTutor = project.tutorRef && project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have permission to add members to this project' });
    }

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ error: 'User not found' });
    if (project.members.some(m => m.user.toString() === userId)) {
      return res.status(400).json({ error: 'User is already a member of this project' });
    }

    project.members.push({ user: userId, role: role || 'STUDENT', dateJoined: new Date() });
    await project.save();
    await project.populate('members.user', 'firstName lastName email');

    return res.json(project);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.removeProjectMember = async (req, res) => {
  try {
    const { userId } = req.params;
    const project = await Project.findById(req.params.id);
    if (!project) return res.status(404).json({ error: 'Project not found' });

    const isTutor = project.tutorRef && project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have permission to remove members from this project' });
    }

    if (project.tutorRef && project.tutorRef.toString() === userId) {
      return res.status(400).json({ error: 'Cannot remove the project tutor' });
    }

    project.members = project.members.filter(m => m.user.toString() !== userId);
    await project.save();

    return res.json({ message: 'Member removed successfully' });
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.getProjectStats = async (req, res) => {
  try {
    const project = await Project.findById(req.params.id);
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }

    const tasks = await Task.find({ projectRef: project._id });

    const totalTasks = tasks.length;
    const completedTasks = tasks.filter(t => t.status === 'COMPLETED').length;
    const inProgressTasks = tasks.filter(t => t.status === 'IN_PROGRESS').length;
    const todoTasks = tasks.filter(t => t.status === 'TODO').length;
    const reviewTasks = tasks.filter(t => t.status === 'REVIEW').length;

    await project.updateProgress();

    return res.json({
      totalTasks,
      completedTasks,
      inProgressTasks,
      todoTasks,
      reviewTasks,
      progressPercentage: project.progressPercentage,
      memberCount: project.members.length
    });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.assignClassesToProject = async (req, res) => {
  try {
    const { projectId, classIds } = req.body;
    console.log('Received payload:', { projectId, classIds });

    if (!projectId || !Types.ObjectId.isValid(projectId)) {
      return res.status(400).json({ error: 'Invalid project ID' });
    }

    const project = await Project.findById(projectId);
    if (!project) return res.status(404).json({ error: 'Project not found' });

    const isTutor = project.tutorRef && project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have permission to assign classes to this project' });
    }

    if (Array.isArray(classIds)) {
      const classes = await Class.find({ _id: { $in: classIds } });
      console.log('Found classes:', classes);
      if (classes.length !== classIds.length) {
        const invalidIds = classIds.filter(id => !classes.some(cls => cls._id.toString() === id));
        return res.status(400).json({ message: 'One or more class IDs are invalid', invalidIds });
      }
      project.classes = classIds; // Explicitly set the classes array
    } else {
      project.classes = [];
    }

    await project.save({ validateBeforeSave: true }); // Ensure validation and save
    console.log('Project saved:', project.toObject()); // Log the full object after save
    const updatedProject = await Project.findById(projectId).populate('classes', 'name description');
    console.log('Populated project after save:', updatedProject);

    return res.json(updatedProject);
  } catch (err) {
    console.error('Error in assignClassesToProject:', err);
    return res.status(400).json({ error: err.message });
  }
};
================================================================================
FILE: controllers\studentResumeController.js
================================================================================

// controllers/studentResumeController.js
const StudentResume = require('../models/studentResumeModel');

exports.createStudentResume = async (req, res) => {
  try {
    const studentResume = new StudentResume(req.body);
    await studentResume.save();
    return res.status(201).json(studentResume);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.getAllStudentResumes = async (req, res) => {
  try {
    const resumes = await StudentResume.find().populate('userRef');
    return res.json(resumes);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.getStudentResumeById = async (req, res) => {
  try {
    const resume = await StudentResume.findById(req.params.id).populate('userRef');
    if (!resume) {
      return res.status(404).json({ error: 'Student resume not found' });
    }
    return res.json(resume);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.updateStudentResume = async (req, res) => {
  try {
    const resume = await StudentResume.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    if (!resume) {
      return res.status(404).json({ error: 'Student resume not found' });
    }
    return res.json(resume);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.deleteStudentResume = async (req, res) => {
  try {
    const resume = await StudentResume.findByIdAndDelete(req.params.id);
    if (!resume) {
      return res.status(404).json({ error: 'Student resume not found' });
    }
    return res.json({ message: 'Student resume deleted successfully' });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

================================================================================
FILE: controllers\taskController.js
================================================================================

const Task = require('../models/taskModel');
const Project = require('../models/projectModel');
const mongoose = require('mongoose');

exports.createTask = async (req, res) => {
  try {
    const { title, description, status, priority, assignedTo, dueDate, startDate, estimatedHours, projectRef, milestoneRef } = req.body;

    const project = await Project.findById(projectRef);
    if (!project) return res.status(404).json({ error: 'Project not found' });

    const isMember = project.members.some(m => m.user.toString() === req.user.id);
    const isTutor = project.tutorRef && project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isMember && !isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have permission to create tasks in this project' });
    }

    const task = new Task({
      title,
      description,
      status: status || 'TODO',
      priority: priority || 'MEDIUM',
      createdBy: req.user.id,
      assignedTo,
      dueDate,
      startDate,
      estimatedHours,
      projectRef,
      milestoneRef
    });

    await task.save();
    await task.populate('createdBy', 'firstName lastName email');
    if (assignedTo) await task.populate('assignedTo', 'firstName lastName email');

    return res.status(201).json(task);
  } catch (err) {
    console.error('Error creating task:', err);
    return res.status(400).json({ error: err.message });
  }
};

exports.getAllTasks = async (req, res) => {
  try {
    const { projectId, status, priority, assignedTo, search } = req.query;
    const filter = {};

    if (status) filter.status = status;
    if (priority) filter.priority = priority;
    if (assignedTo) filter.assignedTo = assignedTo;
    if (search) {
      filter.$or = [
        { title: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { tags: { $regex: search, $options: 'i' } }
      ];
    }

    if (req.user.role === 'STUDENT') {
      const userProjects = await Project.find({ 'members.user': req.user.id }).select('_id');
      filter.projectRef = { $in: userProjects.map(p => p._id) };
    } else if (req.user.role === 'TUTOR') {
      const tutorProjects = await Project.find({ tutorRef: req.user.id }).select('_id');
      filter.projectRef = { $in: tutorProjects.map(p => p._id) };
    }
    // Admins see all tasks (no projectRef filter)

    if (projectId) filter.projectRef = projectId;

    const tasks = await Task.find(filter)
        .populate('createdBy', 'firstName lastName email')
        .populate('assignedTo', 'firstName lastName email')
        .populate('projectRef', 'name status')
        .sort({ createdAt: -1 });

    return res.json(tasks);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.getTaskById = async (req, res) => {
  try {
    const task = await Task.findById(req.params.id)
        .populate('createdBy', 'firstName lastName email')
        .populate('assignedTo', 'firstName lastName email')
        .populate('projectRef', 'name status members tutorRef')
        .populate({ path: 'comments.author', select: 'firstName lastName email' });

    if (!task) return res.status(404).json({ error: 'Task not found' });

    const project = await Project.findById(task.projectRef);
    if (!project) return res.status(404).json({ error: 'Associated project not found' });

    const isMember = project.members.some(m => m.user.toString() === req.user.id);
    const isTutor = project.tutorRef && project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isMember && !isTutor && !isAdmin) return res.status(403).json({ error: 'You do not have access to this task' });

    return res.json(task);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.updateTask = async (req, res) => {
  try {
    const { title, description, status, priority, assignedTo, dueDate, startDate, completedDate, estimatedHours, actualHours, tags } = req.body;

    const task = await Task.findById(req.params.id);
    if (!task) return res.status(404).json({ error: 'Task not found' });

    const project = await Project.findById(task.projectRef);
    if (!project) return res.status(404).json({ error: 'Associated project not found' });

    const isTutor = project.tutorRef && project.tutorRef.toString() === req.user.id;
    const isCreator = task.createdBy.toString() === req.user.id;
    const isAssigned = task.assignedTo && task.assignedTo.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isAssigned && !isCreator && !isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have permission to update this task' });
    }

    if (status === 'COMPLETED' && task.status !== 'COMPLETED') task.completedDate = new Date();

    if (title !== undefined) task.title = title;
    if (description !== undefined) task.description = description;
    if (status !== undefined) task.status = status;
    if (priority !== undefined) task.priority = priority;
    if (assignedTo !== undefined) task.assignedTo = assignedTo;
    if (dueDate !== undefined) task.dueDate = dueDate;
    if (startDate !== undefined) task.startDate = startDate;
    if (estimatedHours !== undefined) task.estimatedHours = estimatedHours;
    if (actualHours !== undefined) task.actualHours = actualHours;
    if (tags !== undefined) task.tags = tags;

    await task.save();
    await project.updateProgress();

    await task.populate('createdBy', 'firstName lastName email');
    await task.populate('assignedTo', 'firstName lastName email');
    await task.populate('projectRef', 'name status');

    return res.json(task);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.deleteTask = async (req, res) => {
  try {
    const task = await Task.findById(req.params.id);
    if (!task) return res.status(404).json({ error: 'Task not found' });

    const project = await Project.findById(task.projectRef);
    if (!project) return res.status(404).json({ error: 'Associated project not found' });

    const isTutor = project.tutorRef && project.tutorRef.toString() === req.user.id;
    const isCreator = task.createdBy.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isCreator && !isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have permission to delete this task' });
    }

    await Task.findByIdAndDelete(req.params.id);
    await project.updateProgress();

    return res.json({ message: 'Task deleted successfully' });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.addComment = async (req, res) => {
  try {
    const { content } = req.body;
    if (!content) return res.status(400).json({ error: 'Comment content is required' });
    
    const task = await Task.findById(req.params.id);
    if (!task) return res.status(404).json({ error: 'Task not found' });
    
    const project = await Project.findById(task.projectRef);
    if (!project) return res.status(404).json({ error: 'Associated project not found' });
    
    const isMember = project.members.some(m => m.user.toString() === req.user.id);
    const isTutor = project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';
    
    if (!isMember && !isTutor && !isAdmin) return res.status(403).json({ error: 'You do not have permission to comment on this task' });
    
    const comment = { author: req.user.id, content, createdAt: new Date(), updatedAt: new Date() };
    task.comments.push(comment);
    await task.save();
    
    await task.populate({ path: 'comments.author', select: 'firstName lastName email' });
    const newComment = task.comments[task.comments.length - 1];
    
    return res.status(201).json(newComment);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.getComments = async (req, res) => {
  try {
    const task = await Task.findById(req.params.id).populate({ path: 'comments.author', select: 'firstName lastName email' });
    if (!task) return res.status(404).json({ error: 'Task not found' });
    
    const project = await Project.findById(task.projectRef);
    if (!project) return res.status(404).json({ error: 'Associated project not found' });
    
    const isMember = project.members.some(m => m.user.toString() === req.user.id);
    const isTutor = project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';
    
    if (!isMember && !isTutor && !isAdmin) return res.status(403).json({ error: 'You do not have access to this task' });
    
    return res.json(task.comments);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.getMyTasks = async (req, res) => {
  try {
    const { status } = req.query;
    const filter = { assignedTo: req.user.id };
    if (status) filter.status = status;
    
    const tasks = await Task.find(filter)
      .populate('createdBy', 'firstName lastName email')
      .populate('projectRef', 'name status')
      .sort({ dueDate: 1, priority: -1 });
      
    return res.json(tasks);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.getTutorTasks = async (req, res) => {
  try {
    const tutorId = req.user.id;
    const projects = await Project.find({ tutorRef: tutorId });
    const projectIds = projects.map(p => p._id);
    const tasks = await Task.find({ projectRef: { $in: projectIds } })
      .populate('createdBy', 'firstName lastName email')
      .populate('assignedTo', 'firstName lastName email')
      .populate('projectRef', 'name status');
    return res.json(tasks);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.getTasksByProject = async (req, res) => {
  try {
    const { projectId } = req.params;
    if (!mongoose.Types.ObjectId.isValid(projectId)) {
      return res.status(400).json({ error: 'Invalid project ID format' });
    }

    const project = await Project.findById(projectId);
    if (!project) return res.status(404).json({ error: 'Project not found' });

    const isMember = project.members.some(m => m.user.toString() === req.user.id);
    const isTutor = project.tutorRef && project.tutorRef.toString() === req.user.id;
    const isAdmin = req.user.role === 'ADMIN';

    if (!isMember && !isTutor && !isAdmin) {
      return res.status(403).json({ error: 'You do not have permission to view tasks for this project' });
    }

    const tasks = await Task.find({ projectRef: projectId })
        .populate('createdBy', 'firstName lastName email')
        .populate('assignedTo', 'firstName lastName email')
        .populate('projectRef', 'name status');

    return res.json(tasks);
  } catch (err) {
    console.error('Error in getTasksByProject:', err.stack);
    return res.status(500).json({ error: 'Internal server error', details: err.message });
  }
};
================================================================================
FILE: controllers\teamController.js
================================================================================

// controllers/teamController.js
const Team = require('../models/teamModel');
const User = require('../models/userModel');
const Class = require('../models/classModel');
const Notification = require('../models/notificationModel');
exports.createTeam = async (req, res) => {
  try {
    if (req.user.role !== 'STUDENT') {
      return res.status(403).json({ message: 'Only students can create teams' });
    }

    const { name, memberIds } = req.body;
    const student = await User.findById(req.user.id);
    if (!student.classe) {
      return res.status(400).json({ message: 'You must be assigned to a class to create a team' });
    }

    if (memberIds && memberIds.length > 0) {
      const classmates = await User.find({
        _id: { $in: memberIds },
        classe: student.classe,
        userRole: 'STUDENT',
      });
      if (classmates.length !== memberIds.length) {
        return res.status(400).json({ message: 'All members must be classmates' });
      }
    }

    const team = new Team({
      name,
      classRef: student.classe,
      createdBy: req.user.id,
      members: [
        { user: req.user.id },
        ...(memberIds ? memberIds.map(id => ({ user: id })) : []),
      ],
      confirmed: false, // Default to unconfirmed
    });

    await team.save();
    await User.updateMany(
        { _id: { $in: team.members.map(m => m.user) } },
        { teamRef: team._id }
    );

    await team.populate('members.user', 'firstName lastName email');
    await team.populate('createdBy', 'firstName lastName email');
    await team.populate('classRef', 'name');

    return res.status(201).json(team);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};
exports.getStudentTeams = async (req, res) => {
  try {
    if (req.user.role !== 'STUDENT') {
      return res.status(403).json({ message: 'Only students can view their teams' });
    }

    const teams = await Team.find({ 'members.user': req.user.id })
        .populate('members.user', 'firstName lastName email')
        .populate('createdBy', 'firstName lastName email')
        .populate('classRef', 'name');

    // Fetch tutor for the class
    const teamsWithTutor = await Promise.all(
        teams.map(async (team) => {
          const classData = await Class.findById(team.classRef._id).populate('tutor', 'firstName lastName');
          return { ...team.toObject(), tutor: classData?.tutor };
        })
    );

    return res.json(teamsWithTutor);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};
exports.updateTeam = async (req, res) => {
  try {
    if (req.user.role !== 'STUDENT') {
      return res.status(403).json({ message: 'Only students can update teams' });
    }

    const team = await Team.findById(req.params.id);
    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    // Only the creator can update the team
    if (team.createdBy.toString() !== req.user.id) {
      return res.status(403).json({ message: 'Only the team creator can update the team' });
    }

    const { name, memberIds } = req.body;

    // Validate new members are classmates
    if (memberIds) {
      const student = await User.findById(req.user.id);
      const classmates = await User.find({
        _id: { $in: memberIds },
        classe: student.classe,
        userRole: 'STUDENT'
      });
      
      if (classmates.length !== memberIds.length) {
        return res.status(400).json({ message: 'All members must be classmates' });
      }

      // Update members
      team.members = memberIds.map(id => ({ user: id }));
      // Ensure creator remains a member
      if (!team.members.some(m => m.user.toString() === req.user.id)) {
        team.members.push({ user: req.user.id });
      }
    }

    if (name) team.name = name;

    await team.save();

    // Update teamRef for all members
    await User.updateMany(
      { teamRef: team._id },
      { $unset: { teamRef: 1 } }
    );
    await User.updateMany(
      { _id: { $in: team.members.map(m => m.user) } },
      { teamRef: team._id }
    );

    await team.populate('members.user', 'firstName lastName email');
    await team.populate('createdBy', 'firstName lastName email');
    await team.populate('classRef', 'name');

    return res.json(team);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.deleteTeam = async (req, res) => {
  try {
    if (req.user.role !== 'STUDENT') {
      return res.status(403).json({ message: 'Only students can delete teams' });
    }

    const team = await Team.findById(req.params.id);
    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    // Only the creator can delete the team
    if (team.createdBy.toString() !== req.user.id) {
      return res.status(403).json({ message: 'Only the team creator can delete the team' });
    }

    // Remove teamRef from all members
    await User.updateMany(
      { teamRef: team._id },
      { $unset: { teamRef: 1 } }
    );

    await Team.findByIdAndDelete(req.params.id);
    return res.json({ message: 'Team deleted successfully' });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};
exports.confirmOrDeleteTeam = async (req, res) => {
  try {
    if (req.user.role !== 'TUTOR') {
      return res.status(403).json({ message: 'Only tutors can confirm or delete teams' });
    }

    const { teamId, action } = req.body;
    const team = await Team.findById(teamId);
    if (!team) {
      return res.status(404).json({ message: 'Team not found' });
    }

    const classData = await Class.findById(team.classRef).populate('tutor');
    if (classData.tutor._id.toString() !== req.user.id) {
      return res.status(403).json({ message: 'You are not the tutor for this team’s class' });
    }

    const memberIds = team.members.map((m) => m.user);

    if (action === 'confirm') {
      console.log('Before update - confirmed:', team.confirmed); // Debug log
      team.confirmed = true;
      await team.save();
      console.log('After update - confirmed:', team.confirmed); // Debug log

      const tutorName = `${req.user.firstName || ''} ${req.user.lastName || ''}`.trim();
      const message = `Your team "${team.name}" has been confirmed by your tutor, ${tutorName}.`;

      const notifications = memberIds.map((userId) => ({
        user: userId,
        message,
      }));
      await Notification.insertMany(notifications);

      await team.populate('members.user', 'firstName lastName email');
      await team.populate('createdBy', 'firstName lastName email');
      await team.populate('classRef', 'name');
      return res.json({ message: 'Team confirmed successfully', team });
    } else if (action === 'delete') {
      const tutorName = `${req.user.firstName || ''} ${req.user.lastName || ''}`.trim();
      const message = `Your team "${team.name}" has been deleted by your tutor, ${tutorName}.`;

      const notifications = memberIds.map((userId) => ({
        user: userId,
        message,
      }));
      await Notification.insertMany(notifications);

      await User.updateMany(
          { teamRef: team._id },
          { $unset: { teamRef: 1 } }
      );
      await Team.findByIdAndDelete(teamId);
      return res.json({ message: 'Team deleted successfully' });
    } else {
      return res.status(400).json({ message: 'Invalid action. Use "confirm" or "delete"' });
    }
  } catch (err) {
    console.error('Error in confirmOrDeleteTeam:', err.message);
    return res.status(500).json({ error: err.message });
  }
};
exports.getAllTeams = async (req, res) => {
  try {
    if (req.user.role !== 'ADMIN' && req.user.role !== 'TUTOR') {
      return res.status(403).json({ message: 'Only admins and tutors can view all teams' });
    }

    const teams = await Team.find()
        .populate('projectRef')
        .populate('members.user', 'firstName lastName email')
        .populate('createdBy', 'firstName lastName email')
        .populate('classRef', 'name');

    const teamsWithTutor = await Promise.all(
        teams.map(async (team) => {
          const classData = await Class.findById(team.classRef._id).populate('tutor', 'firstName lastName');
          return { ...team.toObject(), tutor: classData?.tutor };
        })
    );

    return res.json(teamsWithTutor);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};
exports.getTeamById = async (req, res) => {
  try {
    const team = await Team.findById(req.params.id)
      .populate('projectRef')
      .populate('members.user', 'firstName lastName email')
      .populate('createdBy', 'firstName lastName email')
      .populate('classRef', 'name');
    
    if (!team) {
      return res.status(404).json({ error: 'Team not found' });
    }

    // Students can only see their own teams
    if (req.user.role === 'STUDENT' && 
        !team.members.some(m => m.user.toString() === req.user.id)) {
      return res.status(403).json({ message: 'You do not have access to this team' });
    }

    return res.json(team);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};
================================================================================
FILE: controllers\tutorResumeController.js
================================================================================

// controllers/tutorResumeController.js
const TutorResume = require('../models/tutorResumeModel');

exports.createTutorResume = async (req, res) => {
  try {
    const tutorResume = new TutorResume(req.body);
    await tutorResume.save();
    return res.status(201).json(tutorResume);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.getAllTutorResumes = async (req, res) => {
  try {
    const resumes = await TutorResume.find().populate('userRef');
    return res.json(resumes);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.getTutorResumeById = async (req, res) => {
  try {
    const resume = await TutorResume.findById(req.params.id).populate('userRef');
    if (!resume) {
      return res.status(404).json({ error: 'Tutor resume not found' });
    }
    return res.json(resume);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.updateTutorResume = async (req, res) => {
  try {
    const resume = await TutorResume.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    if (!resume) {
      return res.status(404).json({ error: 'Tutor resume not found' });
    }
    return res.json(resume);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.deleteTutorResume = async (req, res) => {
  try {
    const resume = await TutorResume.findByIdAndDelete(req.params.id);
    if (!resume) {
      return res.status(404).json({ error: 'Tutor resume not found' });
    }
    return res.json({ message: 'Tutor resume deleted successfully' });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

================================================================================
FILE: controllers\userController.js
================================================================================


// controllers/userController.js
const User = require('../models/userModel');

exports.createUser = async (req, res) => {
  try {
    const user = new User(req.body);
    await user.save();
    return res.status(201).json(user);
  } catch (err) {
    return res.status(400).json({ error: err.message });
  }
};

exports.getAllUsers = async (req, res) => {
  try {
    const { role } = req.query;
    let query = {};
    
    if (role) {
      query.userRole = role.toUpperCase();
    }
    
    const users = await User.find(query).populate('teamRef');
    return res.json(users);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.getUserById = async (req, res) => {
  try {
    const user = await User.findById(req.params.id).populate('teamRef');
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    return res.json(user);
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
};

exports.updateUser = async (req, res) => {
  try {
    console.log('Updating user with ID:', req.params.id);
    console.log('Update data:', req.body);

    const updateData = { ...req.body };
    
    // Process special fields as needed
    if (updateData.userRole) {
      console.log('Updating user role to:', updateData.userRole);
    }

    // Use $set to update only the fields provided
    const user = await User.findByIdAndUpdate(
      req.params.id,
      { $set: updateData },
      { new: true, runValidators: true }
    );

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    console.log('Updated user:', user);
    return res.json(user);
  } catch (err) {
    console.error('Update error:', err);
    return res.status(400).json({ message: err.message });
  }
};

exports.deleteUser = async (req, res) => {
  try {
    console.log('Attempting to delete user with ID:', req.params.id);
    
    const user = await User.findById(req.params.id);
    if (!user) {
      console.log('User not found for deletion');
      return res.status(404).json({ message: 'User not found' });
    }

    await User.findByIdAndDelete(req.params.id);
    console.log('User successfully deleted');
    
    return res.json({ 
      message: 'User deleted successfully',
      deletedUser: {
        id: user._id,
        email: user.email,
        userRole: user.userRole
      }
    });
  } catch (err) {
    console.error('Delete error:', err);
    return res.status(500).json({ message: err.message });
  }
};

================================================================================
FILE: routes\auth.js
================================================================================

const router = require("express").Router();
const passport = require("passport");
const jwt = require("jsonwebtoken");

const CLIENT_URL = "http://localhost:5173";
const FAILURE_URL = "http://localhost:5173/signin";

// Initial Google authentication
router.get("/google", 
  passport.authenticate("google", { 
    scope: ["profile", "email"],
    prompt: "select_account"
  })
);

// Initial GitHub authentication
router.get("/github",
  passport.authenticate("github", { 
    scope: ["user:email"],
    allow_signup: true
  })
);

// Google auth callback
router.get(
  "/google/callback",
  (req, res, next) => {
    passport.authenticate("google", { session: true }, async (err, user, info) => {
      if (err) {
        console.error('Authentication error:', err);
        return res.redirect(FAILURE_URL);
      }

      if (!user) {
        console.error('No user found/created');
        return res.redirect(FAILURE_URL);
      }

      try {
        // Generate token with consistent field names
        const token = jwt.sign(
          { 
            id: user._id.toString(),
            email: user.email,
            role: user.userRole || 'STUDENT' // Ensure role is set, default to STUDENT
          },
          process.env.JWT_SECRET || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEyMzQ1NiIsInJvbGUiOiJTVFVERU5UIiwiaWF0IjoxNzQwMTM1NjEyLCJleHAiOjE3NDA3NDA0MTJ9.zUhKAi8PO7X8IAfPcbGw2j2LhdtuLBW6ww2E0VuthXU",
          { expiresIn: '7d' }
        );

        // Log token and user data for debugging
        console.log('Generated token:', token);
        console.log('User data:', {
          id: user._id,
          email: user.email,
          role: user.userRole,
          isGoogleUser: user.isGoogleUser
        });

        // Redirect with token and role
        res.redirect(`${CLIENT_URL}/auth-transfer?token=${token}&role=${user.userRole || 'STUDENT'}`);
      } catch (error) {
        console.error('Token/login error:', error);
        return res.redirect(FAILURE_URL);
      }
    })(req, res, next);
  }
);

// GitHub auth callback
router.get(
  "/github/callback",
  (req, res, next) => {
    passport.authenticate("github", { session: true }, async (err, user, info) => {
      if (err) {
        console.error('GitHub Authentication error:', err);
        return res.redirect(FAILURE_URL);
      }

      if (!user) {
        console.error('No GitHub user found/created');
        return res.redirect(FAILURE_URL);
      }

      try {
        // Generate token with consistent field names
        const token = jwt.sign(
          { 
            id: user._id.toString(),
            email: user.email,
            role: user.userRole 
          },
          process.env.JWT_SECRET || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEyMzQ1NiIsInJvbGUiOiJTVFVERU5UIiwiaWF0IjoxNzQwMTM1NjEyLCJleHAiOjE3NDA3NDA0MTJ9.zUhKAi8PO7X8IAfPcbGw2j2LhdtuLBW6ww2E0VuthXU",
          { expiresIn: '7d' }
        );

        // Set token in cookie
        res.cookie('auth_token', token, {
          httpOnly: false,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
          maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
          path: '/' // Ensure the cookie is available on all paths
        });

        // Log the user in
        req.login(user, (err) => {
          if (err) {
            console.error('Login error:', err);
            return res.redirect(FAILURE_URL);
          }
          res.redirect(`${CLIENT_URL}/auth-transfer`);
        });
      } catch (error) {
        console.error('Token/login error:', error);
        return res.redirect(FAILURE_URL);
      }
    })(req, res, next);
  }
);

// Check authentication status
router.get("/login/success", (req, res) => {
  if (req.user) {
    res.status(200).json({
      success: true,
      message: "Login successful",
      user: req.user,
    });
  } else {
    res.status(403).json({ success: false, message: "Not authorized" });
  }
});

router.get("/login/failed", (req, res) => {
  res.status(401).json({
    success: false,
    message: "Login failed",
  });
});

router.get("/logout", (req, res) => {
  req.logout((err) => {
    if (err) {
      console.error('Logout error:', err);
    }
    res.clearCookie('token');
    res.redirect(CLIENT_URL);
  });
});

module.exports = router; 
================================================================================
FILE: routes\authRoutes.js
================================================================================

const express = require("express");
const authController = require("../controllers/authController");
const router = express.Router();

// Authentication routes
router.post("/register", authController.register);
router.post("/login", authController.login);
router.post("/google", authController.googleLogin);
router.post("/logout", authController.checkTokenValidity, authController.logout);
router.post("/forgot-password", authController.forgotPassword);
router.post("/reset-password", authController.resetPassword);
router.get("/verify-email/:token", authController.verifyEmail);

module.exports = router;
================================================================================
FILE: routes\classRoutes.js
================================================================================

// routes/classRoutes.js
const express = require('express');
const router = express.Router();
const classController = require('../controllers/classController');
const authMiddleware = require('../middlewares/authMiddleware');

// Apply auth middleware to all class routes
router.use(authMiddleware);

// Class CRUD routes
router.post('/', classController.createClass);
router.get('/', classController.getAllClasses);
router.get('/:id', classController.getClassById);
router.put('/:id', classController.updateClass);
router.delete('/:id', classController.deleteClass);

// Add students to a class
router.post('/add-students', classController.addStudentsToClass);

// Get all students for a tutor (across all their classes)
router.get('/tutor/students', classController.getAllStudentsForTutor);

module.exports = router;
================================================================================
FILE: routes\evaluationRoutes.js
================================================================================

// routes/evaluationRoutes.js
const express = require('express');
const router = express.Router();
const evaluationController = require('../controllers/evaluationController');

router.post('/', evaluationController.createEvaluation);
router.get('/', evaluationController.getAllEvaluations);
router.get('/:id', evaluationController.getEvaluationById);
router.put('/:id', evaluationController.updateEvaluation);
router.delete('/:id', evaluationController.deleteEvaluation);

module.exports = router;

================================================================================
FILE: routes\faceDetectionRoutes.js
================================================================================

const express = require('express');
const router = express.Router();
const upload = require('../middlewares/uploadMiddleware');
const path = require('path');
const fs = require('fs');
const User = require('../models/userModel');
const { getFaceDescriptor, compareFaceDescriptors } = require('../utils/faceRecognition');

// Route to handle face image uploads
router.post('/upload', upload.single('faceImage'), async (req, res) => {
  try {
    console.log('File upload request received:', req.file);
    

    
    if (!req.file) {
      console.error('No file in request');
      return res.status(400).json({ message: 'No file uploaded' });
    }

    // Get face descriptor from the uploaded image
    const faceDescriptor = await getFaceDescriptor(req.file.path);
    
    if (!faceDescriptor) {
      console.error('No face detected in the uploaded image');
      return res.status(400).json({ message: 'No face detected in the image' });
    }

    // Return the file path and descriptor that can be stored in the user model
    const filePath = `/uploads/${req.file.filename}`;
    console.log('File uploaded successfully:', filePath);
    
    return res.status(200).json({ 
      message: 'File uploaded successfully',
      filePath: filePath,
      faceDescriptor: Array.from(faceDescriptor) // Convert Float32Array to regular array for JSON
    });
  } catch (error) {
    console.error('Error uploading file:', error);
    return res.status(500).json({ message: 'Error uploading file', error: error.message });
  }
});

// Route to serve the uploaded images
router.get('/:filename', (req, res) => {
  const filename = req.params.filename;
  const filepath = path.join(__dirname, '../uploads', filename);
  console.log('Attempting to serve file:', filepath);
  
  // Check if file exists
  if (fs.existsSync(filepath)) {
    return res.sendFile(filepath);
  } else {
    console.error('File not found:', filepath);
    return res.status(404).json({ message: 'File not found' });
  }
});

// Route for face recognition login
router.post('/login', upload.single('faceImage'), async (req, res) => {
  try {
    console.log('Face login request received:', req.file);
    
    if (!req.file) {
      console.error('No face image in request');
      return res.status(400).json({ message: 'No face image uploaded' });
    }

    // Get face descriptor from the uploaded image
    const loginFaceDescriptor = await getFaceDescriptor(req.file.path);
    
    if (!loginFaceDescriptor) {
      console.error('No face detected in the login image');
      return res.status(400).json({ message: 'No face detected in the image' });
    }
    
    // Get all users with face descriptors
    const users = await User.find({ 
      faceDescriptor: { $exists: true, $ne: null }
    });
    
    if (users.length === 0) {
      return res.status(404).json({ message: 'No users with face data found' });
    }
    
    // Compare the login face with all stored faces
    let bestMatch = null;
    let bestUser = null;
    
    for (const user of users) {
      // Skip users without face descriptors
      if (!user.faceDescriptor || user.faceDescriptor.length === 0) {
        continue;
      }
      
      // Convert stored array back to Float32Array for comparison
      const storedDescriptor = new Float32Array(user.faceDescriptor);
      
      // Compare faces
      const matchResult = compareFaceDescriptors(loginFaceDescriptor, storedDescriptor);
      
      // Check if this is a match and better than previous matches
      if (matchResult.match && (!bestMatch || matchResult.similarity > bestMatch.similarity)) {
        bestMatch = matchResult;
        bestUser = user;
      }
    }
    
    // If we found a match
    if (bestMatch && bestUser) {
      console.log(`Face login successful for user: ${bestUser.email}`);
      
      // Update login stats
      bestUser.lastLogin = new Date();
      bestUser.loginCount += 1;
      await bestUser.save();
      
      // Generate auth token
      const token = bestUser.generateToken();
      
      // Return user data and token
      return res.status(200).json({
        message: 'Face recognition successful',
        similarity: bestMatch.similarity.toFixed(2),
        user: {
          id: bestUser._id,
          firstName: bestUser.firstName,
          lastName: bestUser.lastName,
          email: bestUser.email,
          role: bestUser.userRole
        },
        token
      });
    } else {
      // No match found
      console.log('No matching face found');
      return res.status(401).json({ message: 'Face not recognized' });
    }
  } catch (error) {
    console.error('Face login error:', error);
    return res.status(500).json({ message: 'Face login failed', error: error.message });
  } finally {
    // Clean up the uploaded file
    if (req.file && req.file.path) {
      fs.unlink(req.file.path, err => {
        if (err) console.error('Error removing login face image:', err);
      });
    }
  }
});

module.exports = router;
================================================================================
FILE: routes\fileRoutes.js
================================================================================

// routes/fileRoutes.js
const express = require('express');
const router = express.Router();
const fileController = require('../controllers/fileController');
const authMiddleware = require('../middlewares/authMiddleware');

// Apply auth middleware to all file routes
router.use(authMiddleware);

// Upload a file
router.post('/upload', fileController.upload.single('file'), fileController.uploadFile);

// Get files
router.get('/project/:projectId', fileController.getProjectFiles);
router.get('/task/:taskId', fileController.getTaskFiles);
router.get('/:id', fileController.getFileById);

// Download a file
router.get('/:id/download', fileController.downloadFile);

// Delete a file
router.delete('/:id', fileController.deleteFile);

module.exports = router; 
================================================================================
FILE: routes\milestoneRoutes.js
================================================================================

// routes/milestoneRoutes.js
const express = require('express');
const router = express.Router();
const milestoneController = require('../controllers/milestoneController');

router.post('/', milestoneController.createMilestone);
router.get('/', milestoneController.getAllMilestones);
router.get('/:id', milestoneController.getMilestoneById);
router.put('/:id', milestoneController.updateMilestone);
router.delete('/:id', milestoneController.deleteMilestone);

module.exports = router;

================================================================================
FILE: routes\notificationRoutes.js
================================================================================

// routes/notificationRoutes.js
const express = require('express');
const router = express.Router();
const authMiddleware = require('../middlewares/authMiddleware');
const notificationController = require('../controllers/notificationController');

router.use(authMiddleware);

router.get('/', notificationController.getUserNotifications);
router.put('/:id/read', notificationController.markNotificationAsRead);

module.exports = router;
================================================================================
FILE: routes\projectRoutes.js
================================================================================

const express = require('express');
const router = express.Router();
const projectController = require('../controllers/projectController');
const authMiddleware = require('../middlewares/authMiddleware');

router.use(authMiddleware);

router.post('/', projectController.createProject);
router.get('/', projectController.getAllProjects);
router.get('/:id', projectController.getProjectById);
router.put('/:id', projectController.updateProject);
router.delete('/:id', projectController.deleteProject);

router.post('/:id/members', projectController.addProjectMember);
router.delete('/:id/members/:userId', projectController.removeProjectMember);

router.get('/:id/stats', projectController.getProjectStats);
router.put('/assign-classes', projectController.assignClassesToProject);

module.exports = router;
================================================================================
FILE: routes\studentResumeRoutes.js
================================================================================

// routes/studentResumeRoutes.js
const express = require('express');
const router = express.Router();
const studentResumeController = require('../controllers/studentResumeController');

router.post('/', studentResumeController.createStudentResume);
router.get('/', studentResumeController.getAllStudentResumes);
router.get('/:id', studentResumeController.getStudentResumeById);
router.put('/:id', studentResumeController.updateStudentResume);
router.delete('/:id', studentResumeController.deleteStudentResume);

module.exports = router;

================================================================================
FILE: routes\taskRoutes.js
================================================================================

// routes/taskRoutes.js
const express = require('express');
const router = express.Router();
const taskController = require('../controllers/taskController');
const authMiddleware = require('../middlewares/authMiddleware');

// Apply auth middleware to all task routes
router.use(authMiddleware);

// Task CRUD routes
router.post('/', taskController.createTask);
router.get('/', taskController.getAllTasks);
router.get('/my-tasks', taskController.getMyTasks);
router.get('/:id', taskController.getTaskById);
router.put('/:id', taskController.updateTask);
router.delete('/:id', taskController.deleteTask);
router.get('/tutor/tasks', taskController.getTutorTasks);
router.get('/project/:projectId/tasks', taskController.getTasksByProject);
// Task comments
router.post('/:id/comments', taskController.addComment);
router.get('/:id/comments', taskController.getComments);

module.exports = router;
================================================================================
FILE: routes\teamRoutes.js
================================================================================

// routes/teamRoutes.js
const express = require('express');
const router = express.Router();
const teamController = require('../controllers/teamController');
const authMiddleware = require('../middlewares/authMiddleware');

router.use(authMiddleware);

// Student-specific routes
router.post('/', teamController.createTeam);
router.get('/my-teams', teamController.getStudentTeams);
router.put('/:id', teamController.updateTeam);
router.delete('/:id', teamController.deleteTeam);

// General routes
router.get('/', teamController.getAllTeams);
router.get('/:id', teamController.getTeamById);
router.post('/confirm-delete', teamController.confirmOrDeleteTeam); // New route
module.exports = router;
================================================================================
FILE: routes\tutorResumeRoutes.js
================================================================================

// routes/tutorResumeRoutes.js
const express = require('express');
const router = express.Router();
const tutorResumeController = require('../controllers/tutorResumeController');

router.post('/', tutorResumeController.createTutorResume);
router.get('/', tutorResumeController.getAllTutorResumes);
router.get('/:id', tutorResumeController.getTutorResumeById);
router.put('/:id', tutorResumeController.updateTutorResume);
router.delete('/:id', tutorResumeController.deleteTutorResume);

module.exports = router;

================================================================================
FILE: routes\userRoutes.js
================================================================================


// routes/userRoutes.js
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const User = require('../models/userModel');
const authMiddleware = require('../middlewares/authMiddleware');

// Get user profile - this specific route should come before the /:id route
router.get('/profile', authMiddleware, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    console.error('Profile fetch error:', error);
    res.status(500).json({ message: 'Server error', error: error.message });
  }
});

// Update user profile
router.put('/:id', authMiddleware, async (req, res) => {
  try {
    const updateData = req.body;
    
    // Vérifier si l'utilisateur est autorisé à mettre à jour ce profil
    // Les administrateurs peuvent mettre à jour n'importe quel profil
    // Les utilisateurs normaux ne peuvent mettre à jour que leur propre profil
    if (req.user.id !== req.params.id && req.user.role !== 'ADMIN') {
      return res.status(403).json({ message: 'Not authorized to update this profile' });
    }

    // Find user
    const user = await User.findById(req.params.id);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Mise à jour conditionnelle des champs - ne mettre à jour que les champs présents dans la requête
    if (updateData.firstName !== undefined) user.firstName = updateData.firstName;
    if (updateData.lastName !== undefined) user.lastName = updateData.lastName;
    if (updateData.email !== undefined) user.email = updateData.email;
    if (updateData.profilePicture !== undefined) user.profilePicture = updateData.profilePicture;
    if (updateData.educationLevel !== undefined && user.userRole === 'STUDENT') {
      user.educationLevel = updateData.educationLevel;
    }
    
    // Mise à jour du statut du compte
    if (updateData.accountStatus !== undefined) {
      user.accountStatus = updateData.accountStatus;
    }
    
    // Seuls les administrateurs peuvent modifier le rôle et la classe d'un utilisateur
    if (req.user.role === 'ADMIN') {
      // Update role if provided
      if (updateData.userRole !== undefined) {
        user.userRole = updateData.userRole;
      }
      
      // Update class for students
      if (user.userRole === 'STUDENT' && updateData.classe !== undefined) {
        user.classe = updateData.classe;
      }
    }
    
    // Mettre à jour le CIN si fourni et si c'est un étudiant
    if (user.userRole === 'STUDENT' && updateData.cin !== undefined) {
      user.cin = updateData.cin;
    }

    // Update department
    if (updateData.department !== undefined) {
      user.department = updateData.department;
    }

    // Update birth date
    if (updateData.birthDate !== undefined) {
      user.birthDate = updateData.birthDate;
    }

    // Save updated user
    await user.save();

    // Return updated user without password
    const updatedUser = await User.findById(req.params.id).select('-password');
    res.json(updatedUser);
  } catch (error) {
    console.error('Profile update error:', error);
    res.status(500).json({ message: 'Error updating profile', error: error.message });
  }
});

// Other routes
router.post('/', userController.createUser);
router.get('/', userController.getAllUsers);
router.get('/:id', userController.getUserById);
router.delete('/:id', userController.deleteUser);

module.exports = router;
================================================================================
FILE: routes\users.js
================================================================================

// routes/users.js
const express = require('express');
const router = express.Router();
const authMiddleware = require('../middleware/authMiddleware'); // Adjust path if needed
const User = require('../models/userModel'); // Point to your userModel.js

// Get all tutors (for admin use)
router.get('/tutors', authMiddleware, async (req, res) => {
    try {
        const tutors = await User.find({ userRole: 'TUTOR' }, 'firstName lastName _id');
        res.json(tutors);
    } catch (error) {
        console.error('Error fetching tutors:', error);
        res.status(500).json({ error: 'Failed to fetch tutors' });
    }
});

module.exports = router;
================================================================================
FILE: middlewares\authMiddleware.js
================================================================================

const jwt = require("jsonwebtoken");

const authMiddleware = (req, res, next) => {
  try {
    // Get token from Authorization header
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ message: 'Authorization header is missing' });
    }

    if (!authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ message: 'Invalid token format. Must be Bearer token' });
    }

    const token = authHeader.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'Token is missing' });
    }
    
    // Verify token
    const decoded = jwt.verify(
      token, 
      process.env.JWT_SECRET || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEyMzQ1NiIsInJvbGUiOiJTVFVERU5UIiwiaWF0IjoxNzQwMTM1NjEyLCJleHAiOjE3NDA3NDA0MTJ9.zUhKAi8PO7X8IAfPcbGw2j2LhdtuLBW6ww2E0VuthXU"
    );
    
    if (!decoded.id) {
      return res.status(401).json({ message: 'Invalid token structure - missing user ID' });
    }

    // Add user info to request
    req.user = {
      id: decoded.id,
      email: decoded.email,
      role: decoded.role
    };

    next();
  } catch (error) {
    console.error('Auth middleware error:', error);
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ message: 'Token has expired' });
    }
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ message: 'Invalid token' });
    }
    return res.status(401).json({ message: 'Authentication failed' });
  }
};

module.exports = authMiddleware;
================================================================================
FILE: middlewares\uploadMiddleware.js
================================================================================

const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Ensure uploads directory exists
const uploadDir = path.join(__dirname, '../uploads');
if (!fs.existsSync(uploadDir)) {
  console.log('Creating uploads directory:', uploadDir);
  fs.mkdirSync(uploadDir, { recursive: true });
}

// Set up storage for uploaded files
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    console.log('File upload destination set to:', uploadDir);
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const fileName = `face_${Date.now()}${path.extname(file.originalname)}`;
    console.log('Generated filename for upload:', fileName);
    cb(null, fileName);
  }
});

// Check file type
const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|gif/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);

  console.log('File filter check:', {
    filename: file.originalname,
    mimetype: file.mimetype,
    isValidExt: extname,
    isValidMime: mimetype
  });

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error('Only image files are allowed!'));
  }
};

// Create the multer instance
const upload = multer({
  storage: storage,
  limits: { fileSize: 5000000 }, // 5MB max file size
  fileFilter: fileFilter
});

module.exports = upload; 
================================================================================
FILE: config\authConfig.js
================================================================================

require("dotenv").config();

module.exports = {
    jwtSecret: process.env.JWT_SECRET || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEyMzQ1NiIsInJvbGUiOiJTVFVERU5UIiwiaWF0IjoxNzQwMTM1NjEyLCJleHAiOjE3NDA3NDA0MTJ9.zUhKAi8PO7X8IAfPcbGw2j2LhdtuLBW6ww2E0VuthXU",
    jwtExpiration: "7d", // Token expires in 7 days
};

================================================================================
FILE: config\db.js
================================================================================

// config/db.js
const mongoose = require('mongoose');

const MONGO_URI = 'mongodb://127.0.0.1:27017/medinaLab';

// Préparer le changement à venir dans Mongoose 7
mongoose.set('strictQuery', true);  // ou false, selon ta préférence

const connectDB = async () => {
  try {
    console.log('Attempting to connect with URI:', MONGO_URI);
    await mongoose.connect(MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    console.log('MongoDB connected successfully.');
  } catch (err) {
    console.error('Failed to connect to MongoDB', err);
    process.exit(1);
  }
};

module.exports = connectDB;

================================================================================
FILE: config\githubStrategy.js
================================================================================

const GitHubStrategy = require('passport-github2').Strategy;
const mongoose = require('mongoose');
const User = require('../models/User'); // Adjust the path to your User model

module.exports = function (passport) {
    passport.use(
        new GitHubStrategy(
            {
                clientID: process.env.GITHUB_CLIENT_ID,
                clientSecret: process.env.GITHUB_CLIENT_SECRET,
                callbackURL: process.env.GITHUB_CALLBACK_URL,
                scope: ['user:email']
            },
            async (accessToken, refreshToken, profile, done) => {
                try {
                    console.log("GitHub Profile Data:", profile);

                    const existingUser = await User.findOne({ githubId: profile.id });

                    if (existingUser) {
                        console.log("Existing user found:", existingUser);
                        return done(null, existingUser);
                    }

                    const firstName = profile.displayName ? profile.displayName.split(' ')[0] : 'Unknown';
                    const lastName = profile.displayName ? profile.displayName.split(' ')[1] || 'User' : 'User';

                    const newUser = new User({
                        githubId: profile.id,
                        firstName,
                        lastName,
                        email: profile.emails?.[0]?.value,
                        avatar: profile.photos?.[0]?.value || '',
                        isGithubUser: true
                    });

                    await newUser.save();
                    console.log("New user created:", newUser);
                    return done(null, newUser);
                } catch (error) {
                    console.error("Error in GitHub Strategy:", error);
                    return done(error, null);
                }
            }
        )
    );

    passport.serializeUser((user, done) => {
        done(null, user.id);
    });

    passport.deserializeUser(async (id, done) => {
        try {
            const user = await User.findById(id);
            done(null, user);
        } catch (error) {
            done(error, null);
        }
    });
};

================================================================================
FILE: config\passport.js
================================================================================

const GoogleStrategy = require("passport-google-oauth20").Strategy;
const GitHubStrategy = require("passport-github2").Strategy;
const passport = require("passport");
const User = require("../models/userModel");

const BACKEND_URL = "http://localhost:5001";
const CLIENT_URL = "http://localhost:5173";

const GOOGLE_CONFIG = {
  clientID: "307626813879-okfk3jlk3b3ivq9gcih2qe1je8enr5l4.apps.googleusercontent.com",
  clientSecret: "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",
  callbackURL: `${BACKEND_URL}/auth/google/callback`,
  scope: ["profile", "email"]
};

const GITHUB_CONFIG = {
  clientID: "Ov23li8PPtcOLA4w0sis",
  clientSecret: "e671587747f604e9782b197e6bb067533db9d234",
  callbackURL: `${BACKEND_URL}/auth/github/callback`,
  scope: ["user:email"],
  authorizationURL: "https://github.com/login/oauth/authorize",
  passReqToCallback: true,
  state: true
};

// Debug environment variables
console.log('Passport Config:', {
  GOOGLE_CLIENT_ID: GOOGLE_CONFIG.clientID,
  GITHUB_CLIENT_ID: GITHUB_CONFIG.clientID,
  callbackURL: GOOGLE_CONFIG.callbackURL,
  githubCallbackURL: GITHUB_CONFIG.callbackURL,
  CLIENT_URL: CLIENT_URL
});

// Check for required environment variables
if (!GOOGLE_CONFIG.clientID || !GOOGLE_CONFIG.clientSecret) {
  console.error('Missing required Google OAuth credentials in environment variables');
  process.exit(1);
}

// Google Strategy
passport.use(
  new GoogleStrategy(GOOGLE_CONFIG, async function (accessToken, refreshToken, profile, done) {
    try {
      console.log('Google Profile:', {
        id: profile.id,
        displayName: profile.displayName,
        email: profile.emails?.[0]?.value,
        firstName: profile.name?.givenName,
        lastName: profile.name?.familyName
      });

      // Check if user exists by email
      let user = await User.findOne({ email: profile.emails[0].value });
      console.log('Existing user:', user);

      if (user) {
        // If user exists but does not have Google ID, update it
        if (!user.googleId) {
          user.googleId = profile.id;
          user.isGoogleUser = true;
          await user.save();
        }
        return done(null, user);
      }

      // Generate a temporary CIN for Google users
      const tempCin = 'G' + Date.now().toString().slice(-7);

      // If no user exists, create a new one with STUDENT role
      const userData = {
        googleId: profile.id,
        firstName: profile.name?.givenName || profile.displayName.split(' ')[0],
        lastName: profile.name?.familyName || profile.displayName.split(' ')[1] || '',
        email: profile.emails[0].value,
        avatar: profile.photos?.[0]?.value,
        isGoogleUser: true,
        userRole: 'STUDENT',
        accountStatus: true,
        isEmailVerified: true,
        cin: tempCin, // Add temporary CIN
        classe: '--' // Default class
      };

      console.log('Creating new user with data:', userData);
      user = await User.create(userData);
      console.log('New user created:', user);

      return done(null, user);
    } catch (error) {
      console.error('Error in Google Strategy:', error);
      return done(error, null);
    }
  })
);


// GitHub Strategy
passport.use(
  new GitHubStrategy(GITHUB_CONFIG, async function(request, accessToken, refreshToken, profile, done) {
    try {
      if (!profile) {
        return done(new Error("No profile received from GitHub"), null);
      }

      console.log('GitHub Profile:', {
        id: profile.id,
        displayName: profile.displayName,
        username: profile.username,
        email: profile.emails?.[0]?.value,
        avatar: profile.photos?.[0]?.value
      });

      let user = await User.findOne({ githubId: profile.id });
      console.log('Existing user:', user);

      if (!user) {
        const firstName = profile.displayName ? profile.displayName.split(' ')[0] : profile.username;
        const lastName = profile.displayName ? profile.displayName.split(' ').slice(1).join(' ') : 'User';

        // Generate a temporary CIN for GitHub users
        const tempCin = 'GH' + Date.now().toString().slice(-7);

        const userData = {
          githubId: profile.id,
          firstName: firstName,
          lastName: lastName || 'User',
          email: profile.emails?.[0]?.value || `${profile.username}@github.com`,
          avatar: profile.photos?.[0]?.value,
          isGithubUser: true,
          userRole: 'STUDENT',
          accountStatus: true,
          isEmailVerified: true,
          cin: tempCin,
          classe: '--'
        };
        console.log('Creating new user with data:', userData);
        
        user = await User.create(userData);
        console.log('New user created:', user);
      }

      return done(null, user);
    } catch (error) {
      console.error('Error in GitHub Strategy:', error);
      return done(error, null);
    }
  })
);

passport.serializeUser((user, done) => {
  console.log('Serializing user:', user.id);
  done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
  try {
    console.log('Deserializing user:', id);
    const user = await User.findById(id);
    console.log('Deserialized user found:', user ? 'yes' : 'no');
    done(null, user);
  } catch (error) {
    console.error('Deserialize error:', error);
    done(error, null);
  }
});

module.exports = passport;
================================================================================
FILE: utils\faceRecognition.js
================================================================================

const faceapi = require('face-api.js');
const canvas = require('canvas');
const fs = require('fs');
const path = require('path');

// Initialize the canvas environment for face-api.js
const { Canvas, Image, loadImage } = canvas;
faceapi.env.monkeyPatch({ Canvas, Image, ImageData: canvas.ImageData });

// Path to the models
const MODELS_PATH = path.join(__dirname, '../models');

// Load required models
let modelsLoaded = false;
async function loadModels() {
  if (modelsLoaded) return;
  
  // Ensure models directory exists
  if (!fs.existsSync(MODELS_PATH)) {
    fs.mkdirSync(MODELS_PATH, { recursive: true });
  }
  
  try {
    // Set the models path and load the models
    const modelPathSsdMobilenetv1 = path.join(MODELS_PATH, 'ssd_mobilenetv1_model-weights_manifest.json');
    const modelPathFaceLandmark68 = path.join(MODELS_PATH, 'face_landmark_68_model-weights_manifest.json');
    const modelPathFaceRecognition = path.join(MODELS_PATH, 'face_recognition_model-weights_manifest.json');
    
    // Check if models exist, if not use remote models for the first run
    const modelOptions = { 
      outputPath: MODELS_PATH 
    };
    
    // Load models from the server or web
    console.log('Loading face recognition models...');
    
    // For simplicity in this example, we'll load from urls rather than local files
    // In production, you should download these models and load them locally
    await faceapi.nets.ssdMobilenetv1.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models');
    await faceapi.nets.faceLandmark68Net.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models');
    await faceapi.nets.faceRecognitionNet.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models');
    
    console.log('Face recognition models loaded successfully');
    modelsLoaded = true;
  } catch (error) {
    console.error('Error loading face recognition models:', error);
    throw error;
  }
}

// Extract face descriptor from an image
async function getFaceDescriptor(imagePath) {
  try {
    // Ensure models are loaded
    await loadModels();
    
    // Load the image
    const img = await loadImage(imagePath);
    
    // Detect all faces and compute descriptors
    const detections = await faceapi
      .detectAllFaces(img)
      .withFaceLandmarks()
      .withFaceDescriptors();
    
    if (detections.length === 0) {
      console.log('No faces detected in the image');
      return null;
    }
    
    if (detections.length > 1) {
      console.log('Multiple faces detected, using the first one');
    }
    
    // Return the descriptor of the first face
    return detections[0].descriptor;
  } catch (error) {
    console.error('Error getting face descriptor:', error);
    return null;
  }
}

// Compare two face descriptors and return similarity score
function compareFaceDescriptors(descriptor1, descriptor2) {
  if (!descriptor1 || !descriptor2) {
    return { match: false, distance: Infinity };
  }
  
  // Calculate Euclidean distance
  const distance = faceapi.euclideanDistance(descriptor1, descriptor2);
  
  // Threshold for determining a match (lower is better)
  // Values around 0.5-0.6 are good thresholds for face recognition
  const threshold = 0.6;
  
  return {
    match: distance < threshold,
    distance,
    similarity: 1 - distance // Convert to similarity score (0-1)
  };
}

module.exports = {
  loadModels,
  getFaceDescriptor,
  compareFaceDescriptors
}; 
================================================================================
FILE: utils\generateToken.js
================================================================================

const jwt = require("jsonwebtoken");
const { jwtSecret, jwtExpiration } = require("../config/authConfig");

const generateToken = (user) => {
    return jwt.sign(
        { id: user.idUser, role: user.role },
        jwtSecret,
        { expiresIn: jwtExpiration }
    );
};

module.exports = generateToken;

================================================================================
FILE: app.js
================================================================================

require('dotenv').config();
const path = require('path');
const express = require('express');
const cors = require('cors');
const connectDB = require('./config/db');
const session = require('express-session');
const passport = require('passport');
require('./config/passport');

// Import routes
const userRoutes = require('./routes/userRoutes');
const tutorResumeRoutes = require('./routes/tutorResumeRoutes');
const studentResumeRoutes = require('./routes/studentResumeRoutes');
const teamRoutes = require('./routes/teamRoutes');
const projectRoutes = require('./routes/projectRoutes');
const taskRoutes = require('./routes/taskRoutes');
const milestoneRoutes = require('./routes/milestoneRoutes');
const evaluationRoutes = require('./routes/evaluationRoutes');
const notificationRoutes = require('./routes/notificationRoutes');
const authRoutes = require('./routes/authRoutes');
const googleAuthRoutes = require('./routes/auth');
const faceDetectionRoutes = require('./routes/faceDetectionRoutes');
const fileRoutes = require('./routes/fileRoutes');
const classRoutes = require('./routes/classRoutes'); // Add this line

const app = express();

// Connect to MongoDB
connectDB();

// Session configuration
app.use(
  session({
    secret: process.env.COOKIE_KEY || 'medinaLab_secure_cookie_key_2024',
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: process.env.NODE_ENV === 'production',
      maxAge: 24 * 60 * 60 * 1000 // 24 hours
    }
  })
);

// Passport middleware
app.use(passport.initialize());
app.use(passport.session());

// Middleware
app.use(cors({
  origin: 'http://localhost:5173',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
app.use(express.json());

// Serve static files from the React app
app.use(express.static(path.join(__dirname, '../frontend/dist')));

// Serve uploads directory statically
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// API Routes
app.use("/auth", googleAuthRoutes); // Google Auth routes
app.use("/api/auth", authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/tutor-resumes', tutorResumeRoutes);
app.use('/api/student-resumes', studentResumeRoutes);
app.use('/api/teams', teamRoutes);
app.use('/api/projects', projectRoutes);
app.use('/api/tasks', taskRoutes);
app.use('/api/milestones', milestoneRoutes);
app.use('/api/evaluations', evaluationRoutes);
app.use('/api/notifications', notificationRoutes);
app.use('/api/face-detection', faceDetectionRoutes);
app.use('/api/files', fileRoutes);
app.use('/api/classes', classRoutes); // Add this line
// Handle React routing, return all requests to React app
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../frontend/dist', 'index.html'));
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ message: 'Something broke!' });
});

// Server startup with port handling
const startServer = async () => {
  const PORT = 5001;
  try {
    const server = app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });

    server.on('error', (error) => {
      if (error.code === 'EADDRINUSE') {
        console.log(`Port ${PORT} is busy, trying ${PORT + 1}...`);
        server.close();
        app.listen(PORT + 1, () => {
          console.log(`Server running on port ${PORT + 1}`);
        });
      } else {
        console.error('Server error:', error);
      }
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();
================================================================================
FILE: .env
================================================================================

MONGO_URI=mongodb://127.0.0.1:27017/medinaLab
PORT=5001
GOOGLE_CLIENT_ID=307626813879-okfk3jlk3b3ivq9gcih2qe1je8enr5l4.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=****REDACTED****
GITHUB_CLIENT_ID=Ov23li8PPtcOLA4w0sis
GITHUB_CLIENT_SECRET=****REDACTED****
JWT_SECRET=****REDACTED****
COOKIE_KEY=****REDACTED****
CLIENT_URL=http://localhost:5173

================================================================================
FILE: package.json
================================================================================

{
    "name": "backend",
    "version": "1.0.0",
    "description": "Sample Node backend for the class diagram project",
    "main": "app.js",
    "scripts": {
        "start": "node app.js",
        "dev": "nodemon app.js"
    },
    "dependencies": {
        "bcryptjs": "^2.4.3",
        "canvas": "^3.1.0",
        "connect-mongo": "^5.1.0",
        "cookie-parser": "^1.4.7",
        "cookie-session": "^2.1.0",
        "cors": "^2.8.5",
        "crypto-browserify": "^3.12.1",
        "dotenv": "^16.4.7",
        "express": "^4.18.2",
        "express-session": "^1.18.1",
        "express-validator": "^6.15.0",
        "face-api.js": "^0.22.2",
        "google-auth-library": "^9.15.1",
        "jsonwebtoken": "^8.5.1",
        "mailtrap": "^3.4.0",
        "mongoose": "^6.8.0",
        "multer": "^1.4.5-lts.1",
        "node-fetch": "^2.7.0",
        "nodemailer": "^6.10.0",
        "nodemon": "^3.1.9",
        "passport": "^0.7.0",
        "passport-github2": "^0.1.12",
        "passport-google-oauth20": "^2.0.0"
    }
}

================================================================================
FILE: test-env.js
================================================================================

// NOTE: This might contain sensitive information
require('dotenv').config();

console.log('Current directory:', __dirname);
console.log('Environment variables:');
console.log('GOOGLE_CLIENT_ID:', process.env.GOOGLE_CLIENT_ID);
console.log('GOOGLE_CLIENT_SECRET:', process.env.GOOGLE_CLIENT_SECRET);
console.log('COOKIE_KEY:', process.env.COOKIE_KEY);
console.log('CLIENT_URL:', process.env.CLIENT_URL); 